<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Picasun">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/02/15/http/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="HTTP">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.com2023/02/15/HTTP/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Picasun&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="HTTP">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            HTTP -
        
        Picasun&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Your youth will be infinitely revived by Picasun！","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.1","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Picasun&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">HTTP</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Picasun</span>
                            
                                <span class="author-label">KatarinaQueen</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-02-15 16:05:56</span>
        <span class="mobile">2023-02-15 16:05</span>
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="《图解HTTP》"><a href="#《图解HTTP》" class="headerlink" title="《图解HTTP》"></a>《图解HTTP》</h1><p>本书非常适合初学之进行<strong>HTTP</strong>协议的学习，逻辑清晰，配图生动，本文会对关键部分进行不配图的摘录，方便读者进行复习或初学者进行简单了解。</p>
<h2 id="1-了解Web及网络基础"><a href="#1-了解Web及网络基础" class="headerlink" title="1 了解Web及网络基础"></a>1 了解Web及网络基础</h2><h3 id="1-1-使用HTTP协议访问web"><a href="#1-1-使用HTTP协议访问web" class="headerlink" title="1.1 使用HTTP协议访问web"></a>1.1 使用HTTP协议访问web</h3><ul>
<li><p>Web页面不能凭空显示，根据Web浏览器中指定的URL，Web浏览器从Web服务器端获取文件资源（resource）等信息，从而显示出Web页面  </p>
</li>
<li><p>像这种通过发送请求获取服务器资源的Web浏览器等，都可以成为客户端（client）</p>
</li>
<li><p>Web使用一种名为HTTP（HyperText Transfer Protocol），超文本传输协议的协议作为规范，完成从客户端到服务器等一系列运作流程</p>
</li>
<li><p>可以说，web是建立在HTTP协议上通信的</p>
</li>
</ul>
<h3 id="1-2-HTTP的诞生"><a href="#1-2-HTTP的诞生" class="headerlink" title="1.2 HTTP的诞生"></a>1.2 HTTP的诞生</h3><h4 id="1-2-1-为知识共享而规划Web"><a href="#1-2-1-为知识共享而规划Web" class="headerlink" title="1.2.1 为知识共享而规划Web"></a>1.2.1 为知识共享而规划Web</h4><ul>
<li><p>从前互联网只属于少数人，此时HTTP诞生，为了<strong>共享知识</strong></p>
</li>
<li><p>最初设计理念：借助多文档之间的相互关联形成的超文本（HyperText），连成可以互相参阅的万维网（World Wild Web）</p>
</li>
<li><p>已经提出的WWW构建技术</p>
<ul>
<li><p>SGML</p>
</li>
<li><p>HTML</p>
</li>
<li><p>HTTP</p>
</li>
<li><p>URL</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-Web成长时代"><a href="#1-2-2-Web成长时代" class="headerlink" title="1.2.2 Web成长时代"></a>1.2.2 Web成长时代</h4><h4 id="1-2-3-驻足不前的HTTP"><a href="#1-2-3-驻足不前的HTTP" class="headerlink" title="1.2.3 驻足不前的HTTP"></a>1.2.3 驻足不前的HTTP</h4><ul>
<li><p>HTTP&#x2F;0.9 没有作为正式标准被建立，HTTP1.0之前版本的意思</p>
</li>
<li><p>HTTP&#x2F;1.0 1996年5月正式被公布，记载于RFC1945，广泛应用</p>
</li>
<li><p>HTTP&#x2F;1.1</p>
</li>
</ul>
<h3 id="1-3-网络基础TCP-x2F-IP"><a href="#1-3-网络基础TCP-x2F-IP" class="headerlink" title="1.3 网络基础TCP&#x2F;IP"></a>1.3 网络基础TCP&#x2F;IP</h3><p>为了理解HTTP，有必要事先了解一下TCP&#x2F;IP协议族。  </p>
<p>通常使用的网络是在TCP&#x2F;IP协议族的基础上运作的，HTTP属于内部的一个子集  </p>
<p>因为本书为《图解HTTP》，因此仅做了需要学习本协议需要掌握的TCP&#x2F;IP协议族概要，具体可以参阅我的另一篇博客：<a class="link"   target="_blank" rel="noopener" href="http://localhost:1313/post/tcp_ip/" >《TCP&#x2F;IP》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="1-3-1-TCP-x2F-IP协议族"><a href="#1-3-1-TCP-x2F-IP协议族" class="headerlink" title="1.3.1 TCP&#x2F;IP协议族"></a>1.3.1 TCP&#x2F;IP协议族</h4><p>计算机与网络设备需要通信，双方就必须基于相同的方法。不同的硬件，操作系统之间的通信，所有的一切都需要一种规则，我们把这种规则称为协议。  </p>
<p>协议中存在各式各样的内容，从电缆规格到IP选定方法，寻找异地用户方法，Web页面需要做的处理等…  </p>
<p>像这样把与互联网相关联的协议集合起来总称为<strong>TCP&#x2F;IP</strong>。有说法认为这是TCP和IP两种协议，我比较倾向于这是在通信过程中需要使用到的协议族的统称。</p>
<h4 id="1-3-2-TCP-x2F-IP的分层管理"><a href="#1-3-2-TCP-x2F-IP的分层管理" class="headerlink" title="1.3.2 TCP&#x2F;IP的分层管理"></a>1.3.2 TCP&#x2F;IP的分层管理</h4><p>本书中说按照TCP&#x2F;IP协议族按层次分为自顶向下4层：应用层、传输层、网络层和数据联络层。经过校内计算机网络课程的学习应该是五层：应用层、传输层、网络层、数据联络层和物理层。  </p>
<p>分层的好处：某处需要改变设计时，仅需要替换变动的层，不需要整体改动，设计也会相对简单，只需要考虑分派给自己的任务。分层不多做赘述。</p>
<h4 id="1-3-3-TCP-x2F-IP通信传输流"><a href="#1-3-3-TCP-x2F-IP通信传输流" class="headerlink" title="1.3.3 TCP&#x2F;IP通信传输流"></a>1.3.3 TCP&#x2F;IP通信传输流</h4><p>发送端从应用层往下走，接收端则从下层往上走  </p>
<ul>
<li><p>应用层：生成HTTP数据（报文）</p>
</li>
<li><p>传输层：添加TCP首部 </p>
</li>
<li><p>网络层：添加IP首部 形成IP报文</p>
</li>
<li><p>链路层：添加以太网首部 形成MAC帧</p>
</li>
<li><p>物理层：在物理媒介上传输<br>  发送层在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层，就会把对应的首部消去。这种把数据包装起来的做法称为封装（encapsulate）</p>
</li>
</ul>
<h3 id="1-4-与HTTP关系密切的协议：IP、TCP和DNS"><a href="#1-4-与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="1.4 与HTTP关系密切的协议：IP、TCP和DNS"></a>1.4 与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="1-4-1-负责传输的IP协议"><a href="#1-4-1-负责传输的IP协议" class="headerlink" title="1.4.1 负责传输的IP协议"></a>1.4.1 负责传输的IP协议</h4><ul>
<li><p>IP（Internet Protocol）：几乎所有网络系统都会用到IP协议</p>
</li>
<li><p>IP地址指明了被分配到的地址，MAC地址指网卡所属的固定地址，IP地址可以和MAC地址进行配对</p>
</li>
<li><p>IP地址可以变换，但MAC地址基本上不会更改</p>
</li>
<li><p>使用ARP（Address Resolution Proto）协议凭借MAC地址进行通信<br>  <em>IP间通信依赖MAC地址，网络上通信双方在同一个内网（LAN）内的情况很少，通常是通过多台计算机和网络设备的中转才能连接到对方，进行中转时，会利用下一台中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议，用于解析地址，根据通信方的IP地址就可以反查出对应的MAC地址</em></p>
</li>
<li><p>没有人可以全面掌握互联网中的传输情况：路由选择</p>
</li>
</ul>
<h4 id="1-4-2-确保可靠性的TCP协议"><a href="#1-4-2-确保可靠性的TCP协议" class="headerlink" title="1.4.2 确保可靠性的TCP协议"></a>1.4.2 确保可靠性的TCP协议</h4><ul>
<li>TCP位于传输层，提供可靠的字节流服务</li>
<li>把大数据块分割成以报文段为单位的数据包进行管理</li>
<li>TCP协议能够确认数据最终是否送达到对方（三次握手，四次挥手）</li>
</ul>
<h3 id="1-5-负责域名解析的DNS服务"><a href="#1-5-负责域名解析的DNS服务" class="headerlink" title="1.5 负责域名解析的DNS服务"></a>1.5 负责域名解析的DNS服务</h3><ul>
<li>提供域名到IP地址之间的解析服务</li>
<li>计算机既可以被赋予IP地址，也可以被赋予主机名和域名</li>
<li>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务</li>
</ul>
<h3 id="1-6-各种协议与HTTP协议的关系"><a href="#1-6-各种协议与HTTP协议的关系" class="headerlink" title="1.6 各种协议与HTTP协议的关系"></a>1.6 各种协议与HTTP协议的关系</h3><p>举例说明：</p>
<ul>
<li>想浏览一个页面</li>
<li>通过DNS解析IP地址</li>
<li>生成对目标Web服务器的HTTP请求报文</li>
<li>客户端TCP把HTTP报文分割成报文段然后可靠传输</li>
<li>网络层IP搜索对方的地址，一边中转一遍传送</li>
<li>服务器端TCP重组到达的报文段</li>
<li>服务器端HTTP对Web服务器请求的内容进行处理</li>
<li>结果也利用TCP&#x2F;IP回传给客户端</li>
</ul>
<h3 id="1-7-URI和URL"><a href="#1-7-URI和URL" class="headerlink" title="1.7 URI和URL"></a>1.7 URI和URL</h3><h4 id="1-7-1-统一资源标识符"><a href="#1-7-1-统一资源标识符" class="headerlink" title="1.7.1 统一资源标识符"></a>1.7.1 统一资源标识符</h4><ul>
<li><p>URL（Uniform Resource Locator）：表示某一互联网资源</p>
</li>
<li><p>URI（Uniform Resource Identifier）：表示了资源的地点</p>
<ul>
<li>登陆信息 </li>
<li>服务器地址</li>
<li>服务器端口号</li>
<li>带层次的文件路径</li>
<li>查询字符串</li>
<li>片段标识符</li>
</ul>
</li>
<li><p>URL是URI的子集</p>
</li>
</ul>
<p><strong>RFC：制定HTTP协议技术标准的文档</strong><br><strong>（Request for Comments，征求修正意见书）</strong></p>
<h2 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2 简单的HTTP协议"></a>2 简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器之间的通信"></a>2.1 HTTP协议用于客户端和服务器之间的通信</h3><p>HTTP和TCP&#x2F;IP协议族呢爹众多其他协议相同，都用于客户和服务器之间的通信  </p>
<p>请求访问的一端称为客户端，而提供资源响应的称为服务端  </p>
<p>使用HTTP协议就可以明确区分哪一段是客户端，哪一段是服务端  </p>
<h3 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h3><p>请求必定由客户端发出，而由服务器端回复响应，书上还有一些具体通信的例子，在此不举例</p>
<h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><ul>
<li><p>无状态（stateless）协议：不对请求和响应之间的通信状态进行保存</p>
</li>
<li><p>为了更快处理大量事务，确保协议的可伸缩性</p>
</li>
<li><p>随着Web发展，需要保存用户的状态（如：购物网站）</p>
</li>
<li><p>引入Cookie技术，有了Cookie再用HTTP协议通信，就可以管理状态了。</p>
</li>
</ul>
<h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><p>HTTP使用URI定位互联网上的资源，正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。</p>
<h3 id="2-5-告知服务器意图的HTTP方法"><a href="#2-5-告知服务器意图的HTTP方法" class="headerlink" title="2.5 告知服务器意图的HTTP方法"></a>2.5 告知服务器意图的HTTP方法</h3><ul>
<li><p>GET：获取资源（CGI（Common Gateway Interface ，通用网关接口）返回执行后的输出）</p>
</li>
<li><p>POST：传输实体主体（目的不是获取响应的主体内容）</p>
</li>
<li><p>PUT：传输文件 一般Web不用，因为不带自身验证机制，任何人都可以上传（REST架构or配合Web应用程序的验证机制才开放使用PUT）</p>
</li>
<li><p>HEAD：获得报文首部（一般用于确认URI资源的有效性和更新的日期等）</p>
</li>
<li><p>DELETE：删除文件（与PUT相反）</p>
</li>
<li><p>TRACE：追踪路径（让Web服务器将之前的请求通信环回给客户端的方法，不常用，容易引发XST（Cross-Site Tracing），跨站攻击）</p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理（实现用隧道协议进行TCP通信，主要是用SSL和TLS协议把通信内容加密后经过网络隧道传输）</p>
</li>
</ul>
<h3 id="2-6-使用方法下达命令"><a href="#2-6-使用方法下达命令" class="headerlink" title="2.6 使用方法下达命令"></a>2.6 使用方法下达命令</h3><ul>
<li>都用大写字母</li>
</ul>
<h3 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a>2.7 持久连接节省通信量</h3><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。<br>每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。  </p>
<h4 id="2-7-1-持久连接"><a href="#2-7-1-持久连接" class="headerlink" title="2.7.1 持久连接"></a>2.7.1 持久连接</h4><ul>
<li><p><strong>为解决TCP连接问题，HTTP&#x2F;1.1和一部分HTTP&#x2F;1.0想出了持久连接，称为HTTP keep-alive或者HTTP connection reuse 方法。（面经）</strong>  </p>
</li>
<li><p>特点：只要任意一段没有明确提出断开连接，就会保持TCP连接状态</p>
</li>
<li><p>减少TCP重复建立和断开造成的额外开销，减轻了服务器的负载</p>
</li>
<li><p><strong>在HTTP&#x2F;1.1中，所有的连接默认都是持久连接，但在HTTP&#x2F;1.0中并未标准化 （面经）</strong>  </p>
</li>
<li><p>除了服务器端，客户端也需要支持持久连接</p>
</li>
</ul>
<h4 id="2-7-2-管线化"><a href="#2-7-2-管线化" class="headerlink" title="2.7.2 管线化"></a>2.7.2 管线化</h4><ul>
<li><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能，从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后不用等待响应亦可发送下一个请求</p>
</li>
<li><p>相比挨个连接，用的持久连接可以让请求更快结束，而管线化技术比持久连接更加快，请求的次数越多，时间差就越明显</p>
</li>
</ul>
<h3 id="2-8-使用Cookie的状态管理"><a href="#2-8-使用Cookie的状态管理" class="headerlink" title="2.8 使用Cookie的状态管理"></a>2.8 使用Cookie的状态管理</h3><ul>
<li><p>HTTP是无状态的协议</p>
<ul>
<li>不必保存状态，减少CPU和内存的消耗</li>
<li>正因为简单，才能被应用在各种场景里</li>
</ul>
</li>
<li><p>如果要求登陆认证的Web页面本身无法进行状态的管理，每次刷新页面需要</p>
<ul>
<li>再次登陆</li>
<li>在请求报文中附加参数来管理登陆状态</li>
</ul>
</li>
<li><p>保留无状态的特征，又要解决类似的矛盾问题，引入了Cookie技术。</p>
</li>
</ul>
<h4 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h4><ul>
<li><p>通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p>
</li>
<li><p>Cookie会根据从服务端发送的根据响应报中的Set-Cookie的首部字段信息，通知客户端保存Cookie</p>
</li>
<li><p>下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去</p>
</li>
<li><p>客户端收到Cookie后会检查究竟从哪个客户端发来的连接请求，然后对比服务器上的记录得到之前的状态信息。</p>
</li>
</ul>
<p>没有Cookie时：客户端向服务器发送一个请求报文，服务端生成Cookie记住是向谁发送的，在响应报文中添加Cookie后返回，客户端会保存Cookie  </p>
<p>存有Cookie后：客户端会在请求报文中添加Cookie发送给服务端，服务端进行Cookie的检查后进行响应，这样服务器就能分清客户端是谁</p>
<h2 id="3-HTTP报文内的HTTP信息"><a href="#3-HTTP报文内的HTTP信息" class="headerlink" title="3 HTTP报文内的HTTP信息"></a>3 HTTP报文内的HTTP信息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>用于HTTP协议交互的信息被称为HTTP报文，本身是由多行数据构成的字符串文本  </p>
<p>HTTP报文 </p>
<ul>
<li>报文首部（客户&#x2F;服务端需要处理的请求&#x2F;响应的内容及属性）</li>
<li>空行（CR+LF）（回车符+换行符）</li>
<li>报文主体（应该发送的数据）<br>  客户端：请求报文<br>  服务端：响应报文</li>
</ul>
<h3 id="3-2-请求报文及响应报文的结构"><a href="#3-2-请求报文及响应报文的结构" class="headerlink" title="3.2 请求报文及响应报文的结构"></a>3.2 请求报文及响应报文的结构</h3><p><strong>1-请求报文</strong></p>
<ul>
<li>报文首部 <ul>
<li>请求行：包含用于请求的方法、URI、HTTP版本</li>
<li>请求首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
</li>
</ul>
<p><strong>2-响应报文</strong></p>
<ul>
<li>报文首部 <ul>
<li>状态行：包含表示请求和相应的各种条件和属性的各类首部</li>
<li>响应首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
</li>
</ul>
<h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><p>HTTP在传输数据：</p>
<ul>
<li>按照数据原貌直接传输：</li>
<li>通过编码提升传输速率：需要依靠计算机完成，因此消耗更多CPU等资源</li>
</ul>
<h4 id="3-3-1-报文主体和实体主体的差异"><a href="#3-3-1-报文主体和实体主体的差异" class="headerlink" title="3.3.1 报文主体和实体主体的差异"></a>3.3.1 报文主体和实体主体的差异</h4><ul>
<li>报文：HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输</li>
<li>实体：作为请求或响应的有效载荷被传输，由实体首部和实体主体组成<br>  通常，报文主体等于实体主体。</li>
</ul>
<p><strong>当传输中进行编码操作时，实体主体的内容发生变化，导致和报文主体产生差异。</strong></p>
<h4 id="3-3-2-压缩传输的内容编码"><a href="#3-3-2-压缩传输的内容编码" class="headerlink" title="3.3.2 压缩传输的内容编码"></a>3.3.2 压缩传输的内容编码</h4><p>以邮件发送为例，为了让邮件的容量变小，我们可能会先用ZIP压缩文件之后再添加附件进行发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。<br>内容编码必须指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由服务端接受并负责解码</p>
<h4 id="3-3-3-分割发送的分块传输编码"><a href="#3-3-3-分割发送的分块传输编码" class="headerlink" title="3.3.3 分割发送的分块传输编码"></a>3.3.3 分割发送的分块传输编码</h4><p>HTTP通信过程中，请求编码实体资源尚未完全传输完成之前，浏览器无法显示请求页面。  </p>
<p>在传输大容量数据时，通过把数据分割成多块，可以让浏览器逐步显示页面  </p>
<p><strong>HTTP&#x2F;1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按照某种编码方式传输，但只定义作用于分块传输编码中（面经）</strong></p>
<h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了<strong>MIME（Multipurpose Internet Mail Extensions 多用途因特网邮件扩展）</strong>机制，它允许邮件处理文本、图片、视频多个不同类型的数据。  </p>
<p>例如图片等二进制数据都是以ASCII码字符串编码的方式指明，就利用MIME来表述标记数据类型。在MIME扩展中会使用一种称为<strong>多部分对象集合（Multipart）</strong>的方法，来容纳不同类型的数据。  </p>
<p>相应HTTP报文中可以有多种类型的实体</p>
<ul>
<li><p><strong>multipart&#x2F;form-data（Web表单文件上传时使用）</strong></p>
</li>
<li><p><strong>multipart&#x2F;byteranges（状态码206（Partial Content 部分内容）响应报文包含了多个范围的内容时使用）</strong></p>
</li>
<li><p>使用多部分对象集合时，需要在首部字段里加上Content-type字段</p>
</li>
<li><p>使用boundary字符串来划分多部分对象集合指明的各类实体</p>
</li>
<li><p>每个部分类型都可以含有首部字段，另外可以嵌套使用多部分对象集合</p>
</li>
</ul>
<h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><p>从前互联网不好的时候，碰见网络中断就须从头开始下载。</p>
<p>为解决此问题需要可恢复机制  </p>
<p>要实现该功能就需要指定下载的实体范围，这样的请求叫做范围请求（Range Request）  </p>
<p>针对范围请求，相应会返回状态码为206的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明 multipart&#x2F;byteranges 后返回响应报文。  </p>
<p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容</p>
<h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><p>同一个Web网站有可能存在多分同样内容，比如Google英文和中文版  </p>
<p>当浏览器的默认语言为英文or中文，访问URI也会显示对应的英语班或中文版的Web页面  </p>
<p><strong>服务器判断的首部字段：</strong></p>
<ul>
<li>Accept</li>
<li>Accept-Charset （字符集）</li>
<li>Accept-Encoding （编码方式）</li>
<li>Accept-Language （可接受语言）</li>
<li>Content-Language （内容语言）</li>
</ul>
<p>内容协商技术的类型：</p>
<ul>
<li><p>服务器驱动协商：以请求的首部字段为参考（以浏览器发送的信息作为判定的依据）</p>
</li>
<li><p>客户端驱动协商：用户从浏览器选择的可选项列表中手动选择（比如按照OS的类型或浏览器类型，自行切换PC版页面或者手机版页面）</p>
</li>
<li><p>透明协商：服务器端和客户端各自进行内容协商的一种方法</p>
</li>
</ul>
<h2 id="4-返回结果的HTTP状态码"><a href="#4-返回结果的HTTP状态码" class="headerlink" title="4 返回结果的HTTP状态码"></a>4 返回结果的HTTP状态码</h2><p>HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现错误等工作。</p>
<h3 id="4-1-状态码告知从服务器端返回的请求结果"><a href="#4-1-状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知从服务器端返回的请求结果"></a>4.1 状态码告知从服务器端返回的请求结果</h3><p>状态码的指责时当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是否正常处理请求，以三维数字和原因短语组成</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">Informatinnal(信息性状态码)</td>
<td align="center">接受的请求正在处理</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">Server Error（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="4-2-2XX成功"><a href="#4-2-2XX成功" class="headerlink" title="4.2 2XX	成功"></a>4.2 2XX	成功</h3><h4 id="200OK"><a href="#200OK" class="headerlink" title="200	OK"></a>200	OK</h4><p>表示从客户端发来的请求在服务器端被正常处理了</p>
<h4 id="204No-Content"><a href="#204No-Content" class="headerlink" title="204	No Content"></a>204	No Content</h4><p>表示请求已经成功处理，但响应报文中不含实体的主体部分，也不允许返回任何实体主体  </p>
<p>一般只需要从客户端往服务器发送信息，而服务器不需要发送新信息内容的情况下使用</p>
<h4 id="206Partial-Content"><a href="#206Partial-Content" class="headerlink" title="206	Partial Content"></a>206	Partial Content</h4><p>表示客户端进行了范围请求，服务器成功执行请求。<br>（包含Content-Range字段指定的实体内容）</p>
<h3 id="4-3-3XX重定向"><a href="#4-3-3XX重定向" class="headerlink" title="4.3 3XX	重定向"></a>4.3 3XX	重定向</h3><h4 id="301Moved-Permanently"><a href="#301Moved-Permanently" class="headerlink" title="301	Moved Permanently"></a>301	Moved Permanently</h4><p><strong>永久性重定向</strong> </p>
<ul>
<li>表示请求的资源被分配了新的URI，应该按照响应报文的Location字段重新找到它</li>
</ul>
<h4 id="302Found"><a href="#302Found" class="headerlink" title="302	Found"></a>302	Found</h4><p><strong>临时性重定向</strong> </p>
<ul>
<li>表示请求的资源被分配了新的URI，希望用户本次能使用新的URI访问</li>
</ul>
<h4 id="304Not-Modified"><a href="#304Not-Modified" class="headerlink" title="304	Not Modified"></a>304	Not Modified</h4><p>表示客户端发送带条件的请求时，服务器端允许请求访问资源，但存在未满足条件的情况。<br>（与重定向无关）</p>
<h4 id="307Temporary-Redirect"><a href="#307Temporary-Redirect" class="headerlink" title="307	Temporary Redirect"></a>307	Temporary Redirect</h4><p><strong>临时重定向</strong> </p>
<ul>
<li>与 302 Found 有相同的含义</li>
</ul>
<h3 id="4-4-4XX客户端错误"><a href="#4-4-4XX客户端错误" class="headerlink" title="4.4 4XX	客户端错误"></a>4.4 4XX	客户端错误</h3><h4 id="400Bad-Request"><a href="#400Bad-Request" class="headerlink" title="400	Bad Request"></a>400	Bad Request</h4><p>表示请求报文中存在语法错误，需要修改请求的内容</p>
<h4 id="401Unauthorized"><a href="#401Unauthorized" class="headerlink" title="401	Unauthorized"></a>401	Unauthorized</h4><p>表示发送的请求需要有通过HTTP认证的认证信息  </p>
<p>若之前已经进行过1次请求，则表示用户认证失败  </p>
<p>返回含有401的响应必须包含适用于被请求字段的 WWW-Authenticate 首部质询用户信息</p>
<h4 id="403Forbidden"><a href="#403Forbidden" class="headerlink" title="403	Forbidden"></a>403	Forbidden</h4><p>表示对资源的访问被拒绝，或是未获得文件系统的访问授权（从未授权的IP试图访问）</p>
<h4 id="404Not-Found"><a href="#404Not-Found" class="headerlink" title="404	Not Found"></a>404	Not Found</h4><p>服务器上无法找到请求的资源。也可以在服务器端拒绝请求且不想说明理由的时候使用</p>
<h3 id="4-5-5XX服务器错误"><a href="#4-5-5XX服务器错误" class="headerlink" title="4.5 5XX	服务器错误"></a>4.5 5XX	服务器错误</h3><h4 id="500Internal-Server-Error"><a href="#500Internal-Server-Error" class="headerlink" title="500	Internal Server Error"></a>500	Internal Server Error</h4><p>表示服务器端在执行请求时发生了错误，也有可能是Web应用存在bug或临时故障</p>
<h4 id="503Service-Unavailable"><a href="#503Service-Unavailable" class="headerlink" title="503	Service Unavailable"></a>503	Service Unavailable</h4><p>表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求<br>一般会被写入 Retry-After 字段来指明解除以上状况需要的时间</p>
<h2 id="5-与HTTP协作的Web服务器"><a href="#5-与HTTP协作的Web服务器" class="headerlink" title="5 与HTTP协作的Web服务器"></a>5 与HTTP协作的Web服务器</h2><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><p>HTTP&#x2F;1.1 规范允许一台HTTP服务器搭建多个Web站点，即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已经具有多台服务器  </p>
<p>互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问  </p>
<p>所以，如果一台服务器内托管了两个域名，收到请求时就需要弄清究竟要访问那个域名  </p>
<p><strong>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在HOST首部内完整的指定主机名或域名的URI</strong></p>
<h3 id="5-2-通信数据转发程序：代理、网关、隧道"><a href="#5-2-通信数据转发程序：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序：代理、网关、隧道"></a>5.2 通信数据转发程序：代理、网关、隧道</h3><p>HTTP通信时除了客户端和服务端，还有用于数据转发的应用程序，例如代理、网关和隧道。<br>这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接受从那台服务器发送的响应再转发给客户端</p>
<ul>
<li>代理：中间商</li>
<li>网关：服务器2号</li>
<li>隧道：保持连接</li>
</ul>
<h4 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1 代理"></a>5.2.1 代理</h4><ul>
<li><p>接受客户端发送的请求后转发给其他的服务器，不改变请求的URI，直接发送给前方拥有字段的目标服务器</p>
</li>
<li><p><strong>每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息</strong>  </p>
</li>
<li><p>通过设置组织内部的代理服务器可以做到对特定URI访问的控制</p>
</li>
</ul>
<p>使用理由：</p>
<ul>
<li>利用缓存技术减少网络带宽的流量</li>
<li>组织内部针对特定网站的访问控制</li>
<li>……</li>
</ul>
<p><strong>两种代理基准分类：</strong></p>
<ul>
<li><strong>缓存代理</strong><br>  预先将资源的副本保存在代理服务器上，当代理在此收到对相同资源的请求时，就可以不从源u武器获取资源，而是将之前的缓存资源作为响应返回</li>
<li><strong>透明代理</strong><br>  转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理<br>  反之，对报文的内容进行加工的代理被称为非透明代理</li>
</ul>
<h4 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h4><ul>
<li><p>与代理机制相似，且能使通信线路上的服务器提供非HTTP协议服务。  </p>
</li>
<li><p>利用网关能提高通信的安全性，因为可在客户端与网关之间的通信线路上加密以保证连接的安全。</p>
</li>
<li><p>例如：网关可以连接数据库，使用SQL查询语句；购物网站信用卡结算等</p>
</li>
</ul>
<h4 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3 隧道"></a>5.2.3 隧道</h4><ul>
<li><p>隧道可以按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。</p>
</li>
<li><p>隧道的目的是确保客户端能与服务器进行安全的通信。</p>
</li>
<li><p>隧道本身不会解析HTTP请求，保持原样中转给之后的服务器，会在双方断开链接时结束</p>
</li>
<li><p>隧道本身是透明的，客户端不用在意隧道的存在。通过隧道，可以和远距离服务器安全通信</p>
</li>
</ul>
<h3 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h3><ul>
<li>缓存是指代理服务器或客户端本地保存的资源副本，利用缓存可以减少对源服务器的访问，因此也就节省了通信流量和通信时间  </li>
<li>缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源，不用多次处理相同的请求</li>
</ul>
<h4 id="5-3-1-缓存的有效期限（服务器缓存）"><a href="#5-3-1-缓存的有效期限（服务器缓存）" class="headerlink" title="5.3.1 缓存的有效期限（服务器缓存）"></a>5.3.1 缓存的有效期限（服务器缓存）</h4><ul>
<li>缓存有效性问题：缓存服务器会向源服务器确认资源的有效性，若判定缓存失败，缓存服务器将会再次从源服务器上获取<strong>新</strong>资源</li>
</ul>
<h4 id="5-3-2-客户端缓存"><a href="#5-3-2-客户端缓存" class="headerlink" title="5.3.2 客户端缓存"></a>5.3.2 客户端缓存</h4><ul>
<li>缓存不仅可以存在缓存服务器，还可以存在客户端浏览器中，客户缓存被称为临时网络文件（Temporary Internet File）</li>
<li>缓存有效就不必向服务器请求相同的资源</li>
<li>缓存过期会向源服务器确认资源的有效性，若判断浏览器缓存失败，浏览器会再次请求新资源</li>
</ul>
<h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>HTTP出现之前，有很多其他协议</p>
<ul>
<li>FTP（File Transfer Protocol）文件传输协议</li>
<li>NNTP（Network News Transfer Protocol）电子会议室内传输消息的协议</li>
<li>Archie（搜索anonymous FTP公开的文件信息的协议）</li>
</ul>
<h2 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6 HTTP首部"></a>6 HTTP首部</h2><p>HTTP协议的请求和响应报文中比必定包含HTTP首部。本章介绍首部结构以及各字段用法</p>
<h3 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h3><p>HTTP报文结构：</p>
<ul>
<li>报文首部：在客户端和服务器处理时起至关重要作用的信息</li>
<li>空行（CR+LF）</li>
<li>报文主体：所需要的用户和资源的信息</li>
</ul>
<p><strong>请求报文</strong></p>
<ul>
<li>报文<strong>首部</strong><ul>
<li>请求行：包含用于请求的方法、URI、HTTP版本</li>
<li>请求首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
</li>
</ul>
<p><strong>响应报文</strong></p>
<ul>
<li>报文<strong>首部</strong><ul>
<li>状态行：包含表示请求和相应的各种条件和属性的各类首部</li>
<li>响应首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
</li>
</ul>
<h3 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h3><h4 id="6-2-1-HTTP首部字段传递重要信息"><a href="#6-2-1-HTTP首部字段传递重要信息" class="headerlink" title="6.2.1 HTTP首部字段传递重要信息"></a>6.2.1 HTTP首部字段传递重要信息</h4><p>HTTP首部字段是构成HTTP报文的要素之一，使用首部字段事为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h4 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h4><p>HTTP首部字段由首部字段名和字段值构成，中间用冒号：分割  </p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type : txt/html</span><br></pre></td></tr></table></figure></div>

<p>单个HTTP字段首部也可以有多个值</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keep-Alive : timeout=15, max=100</span><br></pre></td></tr></table></figure></div>

<p>若首部字段重复了，看浏览器的内部处理逻辑，有些会优先第一次出现的，有些会优先最后出现的</p>
<h4 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h4><ul>
<li><p>通用首部字段：请求和响应报文双方都会使用的首部</p>
</li>
<li><p>请求首部字段：补充了请求的附加内容、客户端信息、相应内容相关优先级等信息</p>
</li>
<li><p>相应首部字段：补充了相应的附加内容、也会要求客户端附加额外的内容信息</p>
</li>
<li><p>实体首部字段：针对请求报文和响应报文的实体部分用的首部。补充了字段内容更新时间等与实体有关的信息</p>
</li>
</ul>
<h4 id="6-2-4-HTTP-x2F-1-1-首部字段一览"><a href="#6-2-4-HTTP-x2F-1-1-首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1 首部字段一览"></a>6.2.4 HTTP&#x2F;1.1 首部字段一览</h4><p><strong>通用首部字段：</strong>  </p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cache-Control</td>
<td align="center">控制缓存的行为</td>
</tr>
<tr>
<td align="center">Connection</td>
<td align="center">逐跳首部、连接的管理</td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center">创建报文的日期时间</td>
</tr>
<tr>
<td align="center">Pragma</td>
<td align="center">报文指令</td>
</tr>
<tr>
<td align="center">Trailer</td>
<td align="center">报文末段的首部一览</td>
</tr>
<tr>
<td align="center">Transfer-Encoding</td>
<td align="center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td align="center">Upgrade</td>
<td align="center">升级为其他协议</td>
</tr>
<tr>
<td align="center">Via</td>
<td align="center">代理服务器的相关信息</td>
</tr>
<tr>
<td align="center">Warning</td>
<td align="center">错误通知</td>
</tr>
</tbody></table>
<p><strong>请求首部字段</strong></p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">用户代理可以处理的媒体类型</td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">优先的字符集</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">优先的内容编码</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">优先的语言</td>
</tr>
<tr>
<td align="center">Authorization</td>
<td align="center">Web认证信息</td>
</tr>
<tr>
<td align="center">Expect</td>
<td align="center">期待服务器的特定行为</td>
</tr>
<tr>
<td align="center">From</td>
<td align="center">用户的电子邮箱地址</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求字段所在的服务器</td>
</tr>
<tr>
<td align="center">If-Match</td>
<td align="center">比较实体标记（ETag）</td>
</tr>
<tr>
<td align="center">If-None-Match</td>
<td align="center">比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td align="center">If-Modified-Since</td>
<td align="center">比较资源的更新时间</td>
</tr>
<tr>
<td align="center">If-Unmodified-Since</td>
<td align="center">比较资源的更新时间（与If-Modified-Since）</td>
</tr>
<tr>
<td align="center">If-Range</td>
<td align="center">资源未更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td align="center">Max-Forwards</td>
<td align="center">最大传输逐跳数</td>
</tr>
<tr>
<td align="center">Proxy-Authorization</td>
<td align="center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td align="center">Range</td>
<td align="center">实体的字节范围请求</td>
</tr>
<tr>
<td align="center">Referer</td>
<td align="center">对请求中URI的原始获取方</td>
</tr>
<tr>
<td align="center">TE</td>
<td align="center">传输编码的优先级</td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">HTTP客户端程序的信息</td>
</tr>
</tbody></table>
<p><strong>响应首部字段</strong></p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept-Ranges</td>
<td align="center">是否接受字节范围请求</td>
</tr>
<tr>
<td align="center">Age</td>
<td align="center">推算资源创建经过时间</td>
</tr>
<tr>
<td align="center">Etag</td>
<td align="center">资源的匹配信息</td>
</tr>
<tr>
<td align="center">Location</td>
<td align="center">令客户端重定向至指定URI</td>
</tr>
<tr>
<td align="center">Proxy-Authenticate</td>
<td align="center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td align="center">Retry-After</td>
<td align="center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td align="center">Server</td>
<td align="center">HTTP服务器的安装信息</td>
</tr>
<tr>
<td align="center">Vary</td>
<td align="center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td align="center">WWW-Authenticate</td>
<td align="center">服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<p><strong>实体首部字段</strong></p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Allow</td>
<td align="center">资源可支持的HTTP方法</td>
</tr>
<tr>
<td align="center">Content-Encoding</td>
<td align="center">实体主体适用的编码方式</td>
</tr>
<tr>
<td align="center">Content-Language</td>
<td align="center">实体主体的语言</td>
</tr>
<tr>
<td align="center">Content-Length</td>
<td align="center">实体主体的大小（Byte）</td>
</tr>
<tr>
<td align="center">Content-Location</td>
<td align="center">代替对应资源的URI</td>
</tr>
<tr>
<td align="center">Content-MD5</td>
<td align="center">实体主体的报文摘要</td>
</tr>
<tr>
<td align="center">Content-Range</td>
<td align="center">实体主体的位置范围</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">实体主体的媒体类型</td>
</tr>
<tr>
<td align="center">Expires</td>
<td align="center">实体主体过期的日期时间</td>
</tr>
<tr>
<td align="center">Last-Modified</td>
<td align="center">资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h4 id="6-2-5-非HTTP-x2F-1-1首部字段"><a href="#6-2-5-非HTTP-x2F-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h4><p>在HTTP协议通信中使用到的首部字段不限于RFC2616中定义的47种，还有Cooke、Set-Cookie和Content-Disposition等在其他的RFC中定义的首部字段，使用率也很高</p>
<h4 id="6-2-6-End-to-end-首部和-Hop-by-hop-首部"><a href="#6-2-6-End-to-end-首部和-Hop-by-hop-首部" class="headerlink" title="6.2.6 End to end 首部和 Hop-by-hop 首部"></a>6.2.6 End to end 首部和 Hop-by-hop 首部</h4><p>HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成两种类型</p>
<ul>
<li><p>端到端首部（End to end header）<br>  分在此类别中的首部会转发给请求&#x2F;响应对应的最终接受目标，且必须保存在缓存生成的响应中，另外规定他必须被转发。</p>
</li>
<li><p>逐跳首部（Hop-by-hop header）</p>
<ul>
<li>Connection</li>
<li>Keep-Alive</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Authorization</li>
<li>Trailer</li>
<li>TE</li>
<li>Transfer-Encoding</li>
<li>Upgrade<br>  分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP&#x2F;1.1和之后的版本中，如果要用到hop-by-hoy首部，需要提供Connect首部字段。<br>  除了这八个字段，其他都属于端到端首部。</li>
</ul>
</li>
</ul>
<h3 id="6-3-6-4-6-5-6-6-关于四种首部字段的具体-不做赘述"><a href="#6-3-6-4-6-5-6-6-关于四种首部字段的具体-不做赘述" class="headerlink" title="6.3 6.4 6.5 6.6 关于四种首部字段的具体 不做赘述"></a>6.3 6.4 6.5 6.6 关于四种首部字段的具体 不做赘述</h3><h3 id="6-7-为Cookie服务的首部字段"><a href="#6-7-为Cookie服务的首部字段" class="headerlink" title="6.7 为Cookie服务的首部字段"></a>6.7 为Cookie服务的首部字段</h3><p>管理服务器和客户端之间状态的Cookie虽然没有编入标准化HTTP&#x2F;1.1 d的 RFC2616中，但在Web网站得到了广泛的应用。<strong>Cookie的工作机制是用户识别及状态管理。</strong>  </p>
<p>Web网站为了管理用户的状态会把一些数据临时写入用户的计算机内，接着当用户访问该Web网站时，可以通过通信方式取回之前发放的Cookie。  </p>
<p>调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。</p>
<p><strong>为Cookie服务的首部字段</strong></p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
<th align="center">首部类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Set-Cookie</td>
<td align="center">开始状态管理所使用的Cookie信息</td>
<td align="center">响应首部字段</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">服务器接收到的Cookie信息</td>
<td align="center">请求首部字段</td>
</tr>
</tbody></table>
<h4 id="6-7-1-Set-Cookie"><a href="#6-7-1-Set-Cookie" class="headerlink" title="6.7.1 Set-Cookie"></a>6.7.1 Set-Cookie</h4><p><strong>Set-Cookie字段的属性</strong></p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
<th align="center">首部类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Set-Cookie</td>
<td align="center">开始状态管理所使用的Cookie信息</td>
<td align="center">响应首部字段</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">服务器接收到的Cookie信息</td>
<td align="center">请求首部字段</td>
</tr>
</tbody></table>
<h4 id="6-7-1-Cookie"><a href="#6-7-1-Cookie" class="headerlink" title="6.7.1 Cookie"></a>6.7.1 Cookie</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NAME&#x3D;VALUE</td>
<td align="center">赋予COokie的名称和其值（必需）</td>
</tr>
<tr>
<td align="center">expires&#x3D;DATE</td>
<td align="center">Cookie的有效期（不明确则为浏览器关闭前）</td>
</tr>
<tr>
<td align="center">path&#x3D;PATH</td>
<td align="center">将服务器上的文件目录作为Cookie的适用对象         （若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td align="center">domain&#x3D;域名</td>
<td align="center">作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）</td>
</tr>
<tr>
<td align="center">Secure</td>
<td align="center">仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td align="center">HttpOnly</td>
<td align="center">加以限制，使Cookie不能被JavaScript脚本所访问</td>
</tr>
</tbody></table>
<h4 id="6-7-2-Cookie"><a href="#6-7-2-Cookie" class="headerlink" title="6.7.2 Cookie"></a>6.7.2 Cookie</h4><p>首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。</p>
<h2 id="7-确保-Web-安全的-HTTPS"><a href="#7-确保-Web-安全的-HTTPS" class="headerlink" title="7 确保 Web 安全的 HTTPS"></a>7 确保 Web 安全的 HTTPS</h2><p><strong>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。</strong>  </p>
<p><strong>使用 HTTPS 通信机制可以有效地防止这些问题。</strong></p>
<h3 id="7-1-HTTP-的缺点"><a href="#7-1-HTTP-的缺点" class="headerlink" title="7.1 HTTP 的缺点"></a>7.1 HTTP 的缺点</h3><p>HTTP主要有这些不足，列举如下：</p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听（报文明文）</li>
<li>不验证通信方的身份，因此有可能遭遇伪装（爬虫脚本）</li>
<li>无法证明报文的完整性，所以有可能已经遭到篡改（黑客修改）</li>
</ul>
<p>这些问题不仅仅是在HTTP上出现，其他未加密的协议也会存在这类问题。<br>还有某些特定Web服务器和特定的Web浏览器在实际应用中存在的不足，或是语言漏洞</p>
<h4 id="7-1-1-通信使用明文可能会被窃听"><a href="#7-1-1-通信使用明文可能会被窃听" class="headerlink" title="7.1.1 通信使用明文可能会被窃听"></a>7.1.1 通信使用明文可能会被窃听</h4><p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体进行加密。即 HTTP 报文使用明文（指未经加密过的报文）方式发送  </p>
<p><strong>TCP&#x2F;IP是可能被窃听的网络</strong>  </p>
<ul>
<li>按 TCP&#x2F;IP 协议族的工作机制，通信内容在所有的通信线路上都可能遭到窥视  </li>
<li>即使报文加密后，加密之后的报文信息本身还是会被看到的  </li>
<li>窃听只要收集在互联网上流动的数据包（帧），使用抓包工具or嗅探器工具</li>
</ul>
<p><strong>通信加密</strong><br>通过SSL（Secure Socket Layer，安全套接字层）或<br>TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。  </p>
<p><strong>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。（面经）</strong></p>
<p><strong>内容加密</strong><br>对HTTP协议传输的内容本身进行加密（报文主体），通信的本身不加密。  </p>
<p>诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制  </p>
<p>由于该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险  </p>
<h4 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h4><p>HTTP协议中的请求和响应不会对通信方进行确认。也就是说存在服务器是否为发送请求中URI真正指定的主机，返回的响应又是否真的返回到提出请求的客户端等类似问题。</p>
<p><strong>任何人都可以发起请求</strong><br>服务器只要接受到请求，不管对方是谁都会返回一个响应，隐患如下：</p>
<ul>
<li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。<strong>有可能是已经伪装的Web服务器</strong>（假server）</li>
<li>无法确定响应返回到的客户端是否是按真实意图接受相应的那个客户端。<strong>有可能是已伪装的客户端</strong>（假client）</li>
<li>无法确定正在通信的双方是否具备访问权限。因为某些Web服务器上保存着重要的信息， 只想发给特定用户通信的权限（权利问题）</li>
<li>无法判定请求是来自何方、出自谁手（假身份问题）</li>
<li>即使是无意义的请求也会照单全收，无法阻止海量请求下的Dos攻击（Denial of Service，拒绝服务攻击）</li>
</ul>
<p><strong>查明对手的证书</strong><br>虽然使用HTTP协议无法确认通信方，但如果使用SSL则可以。SSL不仅提供了加密处理，还使用了一种被称为证书的手段，可用于确定方。  </p>
<p>证书由值得信任的第三方机构办法，用以证明服务器和客户端是实际存在的。伪造证书非常困难，因此只要能够确定通信方持有的证书，就可以判断通信房的真实意图。  </p>
<p>客户端持有证书及可以完成个人身份的确认，也可以用于对Web网站的认证环节。</p>
<h4 id="7-1-3-无法证明报文的完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文的完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文的完整性，可能已遭篡改"></a>7.1.3 无法证明报文的完整性，可能已遭篡改</h4><p><strong>接收到的内容可能有误</strong><br>由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收到之前的这但时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br>攻击人会随意篡改请求和响应，而让客户端与服务器之间的通信看上去仍旧是正常的。  </p>
<p><strong>如何防止篡改</strong><br>其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。提供文件下载的Web网站也会提供相应的 PGP 创建的数字签名及MD5算法生成的散列值。  </p>
<p>PGP是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值  </p>
<p>可是如果PGP和MD5本身被改写，用户没有办法意识到，为了防止这些弊端，有必要用HTTPS  </p>
<h3 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP + 加密 + 认证 + 完整性保护 &#x3D; HTTPS"></a>7.2 HTTP + 加密 + 认证 + 完整性保护 &#x3D; HTTPS</h3><h4 id="7-2-1-HTTP-加上加密处理和认证以及完整性保护后即是HTTPS"><a href="#7-2-1-HTTP-加上加密处理和认证以及完整性保护后即是HTTPS" class="headerlink" title="7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是HTTPS"></a>7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是HTTPS</h4><p>如果在HTTP协议通信过程中使用未经加密的明文，比如信用卡卡号，如果这条线路遭到窃听，那么信用卡号就暴露了，因此需要在HTTP上再加入加密处理和认证等机制。我们把添加了加密及认证机制的HTTP称为HTTPS（HTTP Secure）  </p>
<p>竟在会在Web登陆页面和购物结算界面等使用HTTPS通信（https:&#x2F;&#x2F;）</p>
<p><strong>公钥 私钥 签名之间的区别</strong><br><strong>公钥是公开的，私钥是私有的，所以Alice给Bob发消息，就要使用Bob公开的公钥来做加密，Bob再用自己的私钥进行解密即可。简单来说，公钥加密，私钥解密。</strong><br><strong>数字签名刚好相反，比如大家想对Alice的签名进行验证，那么大家能获取的就是Alice公开的公钥，而签名则由Alice用自己的私钥进行签名。简单来说，私钥签名，公钥验证<br>（面经）</strong></p>
<h4 id="7-2-2-HTTPS-是身披SSL外壳的HTTP"><a href="#7-2-2-HTTPS-是身披SSL外壳的HTTP" class="headerlink" title="7.2.2 HTTPS 是身披SSL外壳的HTTP"></a>7.2.2 HTTPS 是身披SSL外壳的HTTP</h4><p>HTTPS只是HTTP通信接口部分用SSL和TLS协议代替而已。<br>通常HTTP直接和TCP通信，当使用SSL时，则演变成HTTP先和SSL通信，再又SSL和TCP通信了。简而言之，所谓HTTPS，就是身体SSL协议外壳的HTTP。</p>
<p>采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护 。<strong>SSL是独立于HTTP的协议，所以不光HTTP协议，其他运行在应用层的SMTP和Telnet等剧可以配合SSL协议使用。</strong></p>
<h4 id="7-2-3-相互交换密钥的公开密钥加密技术"><a href="#7-2-3-相互交换密钥的公开密钥加密技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥加密技术"></a>7.2.3 相互交换密钥的公开密钥加密技术</h4><p>SSL采用公开密钥加密的处理方式，近代的加密方法中加密算法是公开的，而密钥是保密的。<br>加密和解密都会用到密钥，没有密钥就没法对密码解密，反过来，只要持有密钥就可以解密。  </p>
<p><strong>共享密钥加密的困境</strong><br>加密和解密用同一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密，以此方式加密时也必须将密钥发送给对方，如果通信被监听那么密钥就可能会落入攻击者之手。  </p>
<p><strong>使用两把密钥的公开密钥加密</strong><br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。<br>发送密文的一方使用对方的公开密钥进行加密，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥。  </p>
<p><strong>HTTPS采用混合加密机制</strong><br>HTTPS采用<strong>共享密钥加密</strong>和<strong>公开密钥加密</strong>两者并用的混合加密机制。如果密钥可以实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密比共享密钥加密慢。</p>
<p><strong>在交换密钥缓解使用公开密钥加密方式，之后的建立通信报文交换阶段利用共享密钥加密方式。</strong></p>
<h4 id="7-2-4-证明公开密钥正确性的证书"><a href="#7-2-4-证明公开密钥正确性的证书" class="headerlink" title="7.2.4 证明公开密钥正确性的证书"></a>7.2.4 证明公开密钥正确性的证书</h4><p>公开密钥加密方法还是存在一些问题的，也就是无法证明公开密钥本身就是货真价实的公开密钥。   </p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。  数字证书认证机构处于客户端和服务器双方都可以信赖的第三方机构的立场上。  </p>
<p><strong>业务流程：</strong>  </p>
<ul>
<li>服务器把自己的公开密钥登陆到数字证书认证机构</li>
<li>数字证书认证机构用自己的私有密钥向服务器的公钥署数字签名并颁发公钥证书</li>
<li>客户端拿到服务器的公钥证书后用数字证书认证机构的公钥来确认服务器公钥的真实性</li>
<li>客户端使用服务器的公钥对报文进行加密发送</li>
<li>服务器用服务器的私钥进行解密</li>
</ul>
<p><strong>用以确认客户端的客户端证书</strong><br>客户端证书用于客户端认证，用来证明服务器正在通信的对方始终是预料之内的客户端。  </p>
<ul>
<li>想要获取证书，用户需要自行安装客户端证书，但要付费</li>
<li>让层次不同的用户自行安装证书，非常困难</li>
<li>现状：安全性极高的认证机构可以颁发客户端证书但仅仅用于特殊业务<br>  例如：网银用客户端证书，登陆时不仅仅需要用户输入ID和密码，还要求用户的客户端证书，以确定用户是否从特定的终端访问网银（U盾）</li>
<li>问题：客户端证书只能证明客户端实际存在，但只要有了<strong>安装了客户端证书的计算机</strong>的使用权限，就等于拥有了<strong>客户端证书</strong>的使用权限</li>
<li></li>
</ul>
<h4 id="7-2-5-HTTPS-的安全通信机制"><a href="#7-2-5-HTTPS-的安全通信机制" class="headerlink" title="7.2.5 HTTPS 的安全通信机制"></a>7.2.5 HTTPS 的安全通信机制</h4><p><strong>流程：</strong><a class="link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1025301" >解释 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li><p>服务器和客户端协商决定加密组件</p>
</li>
<li><p>服务器向客户端发送公开密钥证书</p>
</li>
<li><p>客户端确定证书的有效性并取出公钥</p>
</li>
<li><p>客户端生成一个随机数并用公钥加密后发送给服务器，同时通过加密组件生成master-secret</p>
</li>
<li><p>服务器私钥解密后也通过加密组件生成master-secret</p>
</li>
<li><p>开始加密通信</p>
<ul>
<li>共享密钥加密的密钥</li>
<li>报文校验码的密钥</li>
<li>生成CBC的初始向量：服务器-&gt;客户端、客户端-&gt;服务器 六份信息</li>
</ul>
</li>
</ul>
<p><strong>SSL 和 TLS</strong><br>HTTPS使用SSL和TLS两个协议，SSL1.0在设计之初被发现出问题，就没有实际投入使用。SSL2.0也被发现存在问题，所以很多浏览器直接废除了协议版本。  </p>
<p><strong>SSL速度</strong><br>因为需要服务器、客户端双方加密以及解密处理，因此会消耗CPU和内存等硬件资源。SSL通信部分因为要对通信进行处理，所以时间上又延长了。<br>使用HTTP相比，网络负载会慢2到100倍。针对速度变慢，会使用SSL加速器这种硬件来改善问题，仅仅在SSL处理时发挥SSL加速器的功效，以分担负载。<br>如果每次通信都加密，会消耗相当多的资源，平摊到每一台计算机上时，能够处理的请求数量也必定随之减少。特别是每当那些访问量较多的Web网站在进行加密处理时，他们所承担的负载不容小觑。   </p>
<h2 id="8-确认访问用户身份的认证"><a href="#8-确认访问用户身份的认证" class="headerlink" title="8 确认访问用户身份的认证"></a>8 确认访问用户身份的认证</h2><h2 id="9-基于HTTP的功能追加协议"><a href="#9-基于HTTP的功能追加协议" class="headerlink" title="9 基于HTTP的功能追加协议"></a>9 基于HTTP的功能追加协议</h2><h2 id="10-构建Web内容的技术"><a href="#10-构建Web内容的技术" class="headerlink" title="10 构建Web内容的技术"></a>10 构建Web内容的技术</h2><h2 id="11-Web的攻击技术"><a href="#11-Web的攻击技术" class="headerlink" title="11 Web的攻击技术"></a>11 Web的攻击技术</h2>
            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：HTTP</li>
        <li>Post author：Picasun</li>
        <li>Create time：2023-02-15 16:05:56</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/02/15/HTTP/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/02/15/ModernOS/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">ModernOS</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/02/15/408-os/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">408-os</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">HTTP</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B"><span class="nav-text">《图解HTTP》</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="nav-text">1 了解Web及网络基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AEweb"><span class="nav-text">1.1 使用HTTP协议访问web</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-HTTP%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-text">1.2 HTTP的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E4%B8%BA%E7%9F%A5%E8%AF%86%E5%85%B1%E4%BA%AB%E8%80%8C%E8%A7%84%E5%88%92Web"><span class="nav-text">1.2.1 为知识共享而规划Web</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-Web%E6%88%90%E9%95%BF%E6%97%B6%E4%BB%A3"><span class="nav-text">1.2.2 Web成长时代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E9%A9%BB%E8%B6%B3%E4%B8%8D%E5%89%8D%E7%9A%84HTTP"><span class="nav-text">1.2.3 驻足不前的HTTP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80TCP-x2F-IP"><span class="nav-text">1.3 网络基础TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="nav-text">1.3.1 TCP&#x2F;IP协议族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-TCP-x2F-IP%E7%9A%84%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86"><span class="nav-text">1.3.2 TCP&#x2F;IP的分层管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-TCP-x2F-IP%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81"><span class="nav-text">1.3.3 TCP&#x2F;IP通信传输流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E4%B8%8EHTTP%E5%85%B3%E7%B3%BB%E5%AF%86%E5%88%87%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9AIP%E3%80%81TCP%E5%92%8CDNS"><span class="nav-text">1.4 与HTTP关系密切的协议：IP、TCP和DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E8%B4%9F%E8%B4%A3%E4%BC%A0%E8%BE%93%E7%9A%84IP%E5%8D%8F%E8%AE%AE"><span class="nav-text">1.4.1 负责传输的IP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84TCP%E5%8D%8F%E8%AE%AE"><span class="nav-text">1.4.2 确保可靠性的TCP协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E8%B4%9F%E8%B4%A3%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84DNS%E6%9C%8D%E5%8A%A1"><span class="nav-text">1.5 负责域名解析的DNS服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">1.6 各种协议与HTTP协议的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-URI%E5%92%8CURL"><span class="nav-text">1.7 URI和URL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-1-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">1.7.1 统一资源标识符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE"><span class="nav-text">2 简单的HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-HTTP%E5%8D%8F%E8%AE%AE%E7%94%A8%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">2.1 HTTP协议用于客户端和服务器之间的通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%9A%84%E4%BA%A4%E6%8D%A2%E8%BE%BE%E6%88%90%E9%80%9A%E4%BF%A1"><span class="nav-text">2.2 通过请求和响应的交换达成通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">2.3 HTTP是不保存状态的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%AF%B7%E6%B1%82URI%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90"><span class="nav-text">2.4 请求URI定位资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%91%8A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%84%8F%E5%9B%BE%E7%9A%84HTTP%E6%96%B9%E6%B3%95"><span class="nav-text">2.5 告知服务器意图的HTTP方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8B%E8%BE%BE%E5%91%BD%E4%BB%A4"><span class="nav-text">2.6 使用方法下达命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E8%8A%82%E7%9C%81%E9%80%9A%E4%BF%A1%E9%87%8F"><span class="nav-text">2.7 持久连接节省通信量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="nav-text">2.7.1 持久连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="nav-text">2.7.2 管线化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E4%BD%BF%E7%94%A8Cookie%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-text">2.8 使用Cookie的状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E6%8A%80%E6%9C%AF"><span class="nav-text">Cookie技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF"><span class="nav-text">3 HTTP报文内的HTTP信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-HTTP%E6%8A%A5%E6%96%87"><span class="nav-text">3.1 HTTP报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%8F%8A%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">3.2 请求报文及响应报文的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BC%96%E7%A0%81%E6%8F%90%E5%8D%87%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87"><span class="nav-text">3.3 编码提升传输速率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%8A%A5%E6%96%87%E4%B8%BB%E4%BD%93%E5%92%8C%E5%AE%9E%E4%BD%93%E4%B8%BB%E4%BD%93%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-text">3.3.1 报文主体和实体主体的差异</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%8E%8B%E7%BC%A9%E4%BC%A0%E8%BE%93%E7%9A%84%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81"><span class="nav-text">3.3.2 压缩传输的内容编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%88%86%E5%89%B2%E5%8F%91%E9%80%81%E7%9A%84%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81"><span class="nav-text">3.3.3 分割发送的分块传输编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%8F%91%E9%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88"><span class="nav-text">3.4 发送多种数据的多部分对象集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><span class="nav-text">3.5 获取部分内容的范围请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E8%BF%94%E5%9B%9E%E6%9C%80%E5%90%88%E9%80%82%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">3.6 内容协商返回最合适的内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">4 返回结果的HTTP状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%8A%B6%E6%80%81%E7%A0%81%E5%91%8A%E7%9F%A5%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%9A%84%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C"><span class="nav-text">4.1 状态码告知从服务器端返回的请求结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2XX%E6%88%90%E5%8A%9F"><span class="nav-text">4.2 2XX	成功</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#200OK"><span class="nav-text">200	OK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#204No-Content"><span class="nav-text">204	No Content</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#206Partial-Content"><span class="nav-text">206	Partial Content</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3XX%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">4.3 3XX	重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#301Moved-Permanently"><span class="nav-text">301	Moved Permanently</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#302Found"><span class="nav-text">302	Found</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#304Not-Modified"><span class="nav-text">304	Not Modified</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#307Temporary-Redirect"><span class="nav-text">307	Temporary Redirect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-4XX%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="nav-text">4.4 4XX	客户端错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#400Bad-Request"><span class="nav-text">400	Bad Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#401Unauthorized"><span class="nav-text">401	Unauthorized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#403Forbidden"><span class="nav-text">403	Forbidden</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#404Not-Found"><span class="nav-text">404	Not Found</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-5XX%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-text">4.5 5XX	服务器错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#500Internal-Server-Error"><span class="nav-text">500	Internal Server Error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#503Service-Unavailable"><span class="nav-text">503	Service Unavailable</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">5 与HTTP协作的Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%94%A8%E5%8D%95%E5%8F%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D"><span class="nav-text">5.1 用单台虚拟主机实现多个域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E7%A8%8B%E5%BA%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93"><span class="nav-text">5.2 通信数据转发程序：代理、网关、隧道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E4%BB%A3%E7%90%86"><span class="nav-text">5.2.1 代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E7%BD%91%E5%85%B3"><span class="nav-text">5.2.2 网关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E9%9A%A7%E9%81%93"><span class="nav-text">5.2.3 隧道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-text">5.3 保存资源的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F%E9%99%90%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%89"><span class="nav-text">5.3.1 缓存的有效期限（服务器缓存）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="nav-text">5.3.2 客户端缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#More"><span class="nav-text">More</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-HTTP%E9%A6%96%E9%83%A8"><span class="nav-text">6 HTTP首部</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-HTTP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8"><span class="nav-text">6.1 HTTP报文首部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-HTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">6.2 HTTP首部字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-HTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E4%BC%A0%E9%80%92%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF"><span class="nav-text">6.2.1 HTTP首部字段传递重要信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-HTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="nav-text">6.2.2 HTTP首部字段结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-4%E7%A7%8DHTTP%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.2.3 4种HTTP首部字段类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-HTTP-x2F-1-1-%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E4%B8%80%E8%A7%88"><span class="nav-text">6.2.4 HTTP&#x2F;1.1 首部字段一览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-%E9%9D%9EHTTP-x2F-1-1%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">6.2.5 非HTTP&#x2F;1.1首部字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-6-End-to-end-%E9%A6%96%E9%83%A8%E5%92%8C-Hop-by-hop-%E9%A6%96%E9%83%A8"><span class="nav-text">6.2.6 End to end 首部和 Hop-by-hop 首部</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6-4-6-5-6-6-%E5%85%B3%E4%BA%8E%E5%9B%9B%E7%A7%8D%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E7%9A%84%E5%85%B7%E4%BD%93-%E4%B8%8D%E5%81%9A%E8%B5%98%E8%BF%B0"><span class="nav-text">6.3 6.4 6.5 6.6 关于四种首部字段的具体 不做赘述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E4%B8%BACookie%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">6.7 为Cookie服务的首部字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-Set-Cookie"><span class="nav-text">6.7.1 Set-Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-Cookie"><span class="nav-text">6.7.1 Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-Cookie"><span class="nav-text">6.7.2 Cookie</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E7%A1%AE%E4%BF%9D-Web-%E5%AE%89%E5%85%A8%E7%9A%84-HTTPS"><span class="nav-text">7 确保 Web 安全的 HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-HTTP-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">7.1 HTTP 的缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8%E6%98%8E%E6%96%87%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E7%AA%83%E5%90%AC"><span class="nav-text">7.1.1 通信使用明文可能会被窃听</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E4%B8%8D%E9%AA%8C%E8%AF%81%E9%80%9A%E4%BF%A1%E6%96%B9%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%B0%B1%E5%8F%AF%E8%83%BD%E9%81%AD%E9%81%87%E4%BC%AA%E8%A3%85"><span class="nav-text">7.1.2 不验证通信方的身份就可能遭遇伪装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-%E6%97%A0%E6%B3%95%E8%AF%81%E6%98%8E%E6%8A%A5%E6%96%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%B7%B2%E9%81%AD%E7%AF%A1%E6%94%B9"><span class="nav-text">7.1.3 无法证明报文的完整性，可能已遭篡改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-HTTP-%E5%8A%A0%E5%AF%86-%E8%AE%A4%E8%AF%81-%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-x3D-HTTPS"><span class="nav-text">7.2 HTTP + 加密 + 认证 + 完整性保护 &#x3D; HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-HTTP-%E5%8A%A0%E4%B8%8A%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%92%8C%E8%AE%A4%E8%AF%81%E4%BB%A5%E5%8F%8A%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4%E5%90%8E%E5%8D%B3%E6%98%AFHTTPS"><span class="nav-text">7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是HTTPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-HTTPS-%E6%98%AF%E8%BA%AB%E6%8A%ABSSL%E5%A4%96%E5%A3%B3%E7%9A%84HTTP"><span class="nav-text">7.2.2 HTTPS 是身披SSL外壳的HTTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-%E7%9B%B8%E4%BA%92%E4%BA%A4%E6%8D%A2%E5%AF%86%E9%92%A5%E7%9A%84%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF"><span class="nav-text">7.2.3 相互交换密钥的公开密钥加密技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-4-%E8%AF%81%E6%98%8E%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="nav-text">7.2.4 证明公开密钥正确性的证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-5-HTTPS-%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">7.2.5 HTTPS 的安全通信机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="nav-text">8 确认访问用户身份的认证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%8A%9F%E8%83%BD%E8%BF%BD%E5%8A%A0%E5%8D%8F%E8%AE%AE"><span class="nav-text">9 基于HTTP的功能追加协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%9E%84%E5%BB%BAWeb%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-text">10 构建Web内容的技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF"><span class="nav-text">11 Web的攻击技术</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Picasun</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.1</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2022/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax defer>
                function odometer_init(){
                        let el = document.getElementsByClassName('odometer');
                        for (i = 0; i < el.length; i++) {
                            od = new Odometer({
                                el: el[i],
                                format: '( ddd).dd',
                                duration: 200
                            });
                        }
                }
                odometer_init();
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>





    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
