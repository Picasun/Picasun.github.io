<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Picasun">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/02/15/408-ds/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="408-ds">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.com2023/02/15/408-ds/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Picasun&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="408-ds">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            408-ds -
        
        Picasun&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Your youth will be infinitely revived by Picasun！","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.1","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Picasun&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">408-ds</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Picasun</span>
                            
                                <span class="author-label">KatarinaQueen</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-02-15 16:05:35</span>
        <span class="mobile">2023-02-15 16:05</span>
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <p>听到了大家的保研消息，感慨万分，要是大二能卷绩点，要是大三能打个A类比赛，也没这么多要是，可惜了</p>
<h1 id="45’"><a href="#45’" class="headerlink" title="45’"></a>45’</h1><h2 id="C1-绪论"><a href="#C1-绪论" class="headerlink" title="C1 绪论"></a>C1 绪论</h2><h3 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h3><ul>
<li><p>数据的逻辑结构</p>
<ul>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状结构or网状</li>
</ul>
</li>
<li><p>数据的存储结构</p>
<ul>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ul>
</li>
<li><p>举例：如果逻辑线性，存储可以是顺序，也可以链式</p>
</li>
<li><p>课后习题</p>
<ul>
<li>链式存储节点内存储单元地址连续</li>
<li><strong>读题他妈读干净点，读仔细点</strong></li>
<li>区分逻辑结构和存储结构</li>
</ul>
</li>
</ul>
<h3 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h3><ul>
<li><p>算法特性</p>
<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
</li>
<li><p>好算法</p>
<ul>
<li>确定性</li>
<li>可读性</li>
<li>健壮性</li>
<li>效率与低存储需求</li>
</ul>
</li>
<li><p>度量算法	</p>
<ul>
<li>时间复杂度<ul>
<li>用一条语句在算法中被重复的次数来计算</li>
<li>所有语句频度之和为T(n)</li>
</ul>
</li>
<li>空间复杂度  <ul>
<li>辅助空间大小</li>
</ul>
</li>
</ul>
</li>
<li><p>课后习题：</p>
<ul>
<li><strong>小题就TM看看复杂度，还行，大题可能结合你写的算法问吧</strong></li>
<li>比如1+2+3 （每次加一个数字），加到n的复杂度</li>
<li>就是计算第几次加&#x3D;n，然后根据量级判断</li>
</ul>
</li>
</ul>
<h2 id="C2-线性表"><a href="#C2-线性表" class="headerlink" title="C2 线性表"></a>C2 线性表</h2><h3 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h3><ul>
<li><p>相同数据类型的有限序列</p>
</li>
<li><p>直接前驱、直接后继</p>
</li>
<li><p>线性表是逻辑结构</p>
</li>
<li><p>基本操作	(408考试也不能直接用，白打)</p>
<ul>
<li>初始化表 <ul>
<li>InitList(&amp;L)</li>
</ul>
</li>
<li>求表长<ul>
<li>Length(L)</li>
</ul>
</li>
<li>按值查找操作<ul>
<li>LocateElem(L,e)</li>
</ul>
</li>
<li>按位查找操作<ul>
<li>GetElem(L,i)</li>
</ul>
</li>
<li>插入操作<ul>
<li>ListInsert(&amp;L,i,e)</li>
</ul>
</li>
<li>删除操作<ul>
<li>ListDelete(&amp;L,i,&amp;e)</li>
</ul>
</li>
<li>输出操作<ul>
<li>PrintList(L)</li>
</ul>
</li>
<li>判空操作<ul>
<li>Empty(L)</li>
</ul>
</li>
<li>销毁操作	 <ul>
<li>Destory(&amp;L)</li>
</ul>
</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>不会就是低能</li>
</ul>
</li>
</ul>
<h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><ul>
<li>线性表的顺序表示叫顺序表</li>
<li>逻辑顺序与物理顺序相同（相邻）</li>
<li>线性表中的元素位序是1开始，数组下标0开始</li>
<li>可以静态分配，也可以动态分配</li>
<li>动态分配语句</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = <span class="keyword">new</span> Elemtype[InitSize]; </span><br></pre></td></tr></table></figure></div>


<ul>
<li>移动节点平均次数 <ul>
<li>插入 n&#x2F;2</li>
<li>删除 （n-1）&#x2F;2</li>
<li>查找 （n+1）&#x2F;2 </li>
<li>时间复杂度都是O(n)</li>
</ul>
</li>
<li>课后算法题 ⭐️<ul>
<li>abcdefg <ul>
<li>循环左移动P位 ，整体思想，AB</li>
</ul>
</li>
<li>求两个序列合并之后的中位数<ul>
<li>多讨论情况，分析两个列的中位数大小</li>
<li>我感觉可以直接伪合并有序表</li>
</ul>
</li>
<li>求出一个数列中出现最多的数及其次数（求主元素）<ul>
<li>主元素出现的次数肯定大于等于一半次</li>
<li>找出出现最多的，然后判断他是不是满足主元素的条件</li>
<li>找第一个为flag，第二个相同+1，不同-1，到0时下一个为新flag</li>
<li>再来一次验flag</li>
</ul>
</li>
<li>找出数组中未出现过的最小正整数<ul>
<li>空间换时间，扫描一遍A，然后标记B[A]</li>
<li>B从0开始找到第一个没标记的（&#x3D;&#x3D;0）则为答案</li>
</ul>
</li>
<li>找出距离最小的三元组<ul>
<li>A—-B—-C &#x3D;2AC</li>
<li>因为ABC有序，因此都从最小的开始找，计算距离</li>
<li>计算完距离让里面值最小的一个的指针后移继续判断</li>
<li>记录此时的三元组ijk </li>
<li>统计次数、统计位数、覆盖填写不刷新</li>
</ul>
</li>
</ul>
</li>
<li>常用函数：Reverse、Abs、Min</li>
</ul>
<h3 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h3><ul>
<li><p>单链表</p>
<ul>
<li>数据域和指针域</li>
<li>引入头节点让链表操作一致，有元素时插入删除和没元素时插入删除一致</li>
<li>无论链表是否为空，head都指向头节点 ，head必定非空</li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li>头插建立</li>
<li>尾插建立</li>
<li>按序号查找节点值</li>
<li>按序号查找节点</li>
<li>插入节点</li>
<li>删除节点</li>
<li>求表长</li>
</ul>
</li>
<li><p>双链表</p>
<ul>
<li>有prior和next，能直接找到前趋后继</li>
<li>插入要改四个指针</li>
<li>删除改俩就行，记得free掉节点（另外两个指针自动GG）</li>
</ul>
</li>
<li><p>循环链表（应该是默认带头）</p>
<ul>
<li>循环单链表</li>
<li>循环双链表</li>
</ul>
</li>
<li><p>静态链表</p>
<ul>
<li>借助数组存储，存放数据和下一个元素下标</li>
<li>-1为结尾</li>
</ul>
</li>
<li><p>顺序表和链表的比较</p>
<ul>
<li>存取&#x2F;读写方式<ul>
<li>顺序随机，链表顺序</li>
</ul>
</li>
<li>逻辑结构和物理结构<ul>
<li>顺序表逻辑物理相同</li>
<li>链表不一定，节点内相邻</li>
</ul>
</li>
<li>查找、插入和删除操作<ul>
<li>根据有序无序结合最后一章自己判断</li>
</ul>
</li>
<li>空间分配<ul>
<li>静态不能扩充，过大浪费</li>
<li>动态可扩充但要移动</li>
<li>链表灵活多了捏</li>
</ul>
</li>
</ul>
</li>
<li><p>如何选存储结构</p>
<ul>
<li>基于存储<ul>
<li>难以估计规模长度就链表</li>
<li>链表存储密度低</li>
</ul>
</li>
<li>基于运算<ul>
<li>插入删除多的时候链表</li>
</ul>
</li>
<li>基于环境 <ul>
<li>顺序表容易实现（任何高级语言都有数组）</li>
<li>链表基于指针，前者容易</li>
<li>频繁插入删除的线性表（动态性强）适合链式</li>
</ul>
</li>
</ul>
</li>
<li><p>课后算法题 ⭐️</p>
<ul>
<li>找到单链表倒数第K个位置的元素<ul>
<li>双指针，同步移动，扫描</li>
</ul>
</li>
<li>找单链表表示的两个字符串的公共后缀起始地址<ul>
<li>双指针，先让让的妥协短的到比较后面的对其位</li>
</ul>
</li>
<li>删除绝对值相同的后续元素<ul>
<li>空间换时间，有就删</li>
</ul>
</li>
<li>a1 a2 a3 a4 a5 ……an 变成 a1 an a2 an-1 a3 an-2 ……<ul>
<li>同步走双指针v1v2，找到中间，逆后半段</li>
<li>然后合并</li>
</ul>
</li>
</ul>
</li>
<li><p>蟀操作</p>
<ul>
<li>俩指针同步走</li>
<li>俩指针一个v 一个2v 找中间（两个都先走一步，再看走不走第二步，帅啊！！！！！！）</li>
</ul>
</li>
</ul>
<h2 id="C3-栈、队列、数组"><a href="#C3-栈、队列、数组" class="headerlink" title="C3 栈、队列、数组"></a>C3 栈、队列、数组</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li><p>只允许在一端进行插入或者删除的线性表</p>
</li>
<li><p>栈顶允许插入删除</p>
</li>
<li><p>栈底固定</p>
</li>
<li><p>空栈无元素</p>
</li>
<li><p>卡特兰数Cn 2n&#x2F;（n+1）</p>
</li>
<li><p>操作</p>
<ul>
<li>初始化空栈</li>
<li>进&#x2F;出栈</li>
<li>读栈顶元素</li>
<li>销毁栈</li>
<li>判空</li>
</ul>
</li>
<li><p>栈的状态判断</p>
<ul>
<li>栈空 top为-1</li>
<li>栈满 top为maxsize-1</li>
<li>栈长 l&#x3D;top+1</li>
</ul>
</li>
<li><p>顺序栈</p>
</li>
<li><p>共享栈（两头）</p>
</li>
<li><p>链栈</p>
</li>
<li><p>综合题</p>
<ul>
<li>字符单链表判断构成的字符串是否中心对称<ul>
<li>前一半元素进栈，退出时比较接下来的</li>
</ul>
</li>
<li>判断进退栈操作顺序的合理性</li>
</ul>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><p>也是操作受限制的线性表FIFO</p>
</li>
<li><p>队头&#x2F;首 Front 允许删除的</p>
</li>
<li><p>队尾 Rear 允许插入的</p>
</li>
<li><p>操作</p>
<ul>
<li>初始化队伍</li>
<li>队列判空</li>
<li>入队</li>
<li>出队</li>
<li>读队头元素</li>
</ul>
</li>
<li><p>队列的顺序存储</p>
<ul>
<li>假溢出</li>
</ul>
</li>
<li><p>循环队列</p>
<ul>
<li>front指向对头元素</li>
<li>rear指向对尾巴元素的后一个（空节点）</li>
<li>牺牲一个节点判断满的情况</li>
</ul>
</li>
<li><p>判断条件</p>
<ul>
<li>判空 front &#x3D;&#x3D;  rear</li>
<li>判满 （rear+1）%max&#x3D;&#x3D;front</li>
<li>元素数量 （rear-front+max）</li>
<li>画一个圆 front 从1开始 放元素 rear指向没元素的后一个</li>
<li>0 1 2 3 4 5 （6个空位 maxsize&#x3D;6 但最多放5个元素 牺牲一个单元）</li>
</ul>
</li>
<li><p>链队列</p>
</li>
<li><p>双端队列 </p>
<ul>
<li>两端都可以入队出队</li>
<li>带入验证问题</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>考虑最适合的东西，不仅要考虑操作，还要考虑恢复</li>
<li>选择操作最简单的符合条件的即可</li>
</ul>
</li>
<li><p>综合应用题</p>
<ul>
<li>设计队列<ul>
<li>进出都是O（1）</li>
<li>不能释放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="栈和队列的应用-⭐️"><a href="#栈和队列的应用-⭐️" class="headerlink" title="栈和队列的应用 ⭐️"></a>栈和队列的应用 ⭐️</h3><ul>
<li><p>括号匹配中的应用</p>
<ul>
<li>是否合法计算序列</li>
</ul>
</li>
<li><p>求值中的应用</p>
<ul>
<li>后缀表达式（结合树思考）</li>
<li>ABCD-x+EF&#x2F;- </li>
<li>相当A+Bx（C-D）-E&#x2F;F</li>
<li>后序遍历二叉树</li>
</ul>
</li>
<li><p>递归调用中的应用</p>
<ul>
<li>Fib</li>
</ul>
</li>
<li><p>层次遍历</p>
<ul>
<li>出1入多 队列</li>
</ul>
</li>
<li><p>计算机系统中的应用</p>
<ul>
<li>打印缓冲区</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>栈可以进制转换 </li>
<li>中缀表达式（正常）转后缀表达式</li>
</ul>
</li>
</ul>
<h3 id="数组和特殊矩阵"><a href="#数组和特殊矩阵" class="headerlink" title="数组和特殊矩阵"></a>数组和特殊矩阵</h3><ul>
<li><p>对称阵</p>
</li>
<li><p>三对角矩阵</p>
</li>
<li><p>三角矩阵</p>
</li>
<li><p>稀疏矩阵</p>
<ul>
<li>压缩存储 三元组</li>
<li>十字链表</li>
</ul>
</li>
<li><p>没啥好说的课后习题</p>
</li>
</ul>
<h2 id="C4-串"><a href="#C4-串" class="headerlink" title="C4 串"></a>C4 串</h2><ul>
<li>掌握KMP算法以及next数组的推理过程</li>
</ul>
<h3 id="串的定义和实现"><a href="#串的定义和实现" class="headerlink" title="串的定义和实现"></a>串的定义和实现</h3><ul>
<li>不考</li>
<li>字符数组</li>
</ul>
<h3 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h3><ul>
<li><p>简单的模式匹配算法（暴力匹配算法）</p>
<ul>
<li>匹配的不对则模式串（子串）倒退回起始位置</li>
<li>然后主串的位置后退一个</li>
</ul>
</li>
<li><p>KMP算法 ⭐️</p>
<ul>
<li>减少了不必比较的次数</li>
<li>如果已经匹配相等的前缀序列中有某个后缀正是子串的前缀</li>
<li>那么就可以直接通过滑动模式串</li>
<li>做出部分匹配值的表 Partial Match（PM）</li>
<li>1 2 3 4 5</li>
<li>a b c a c</li>
<li>0 0 0 1 0</li>
<li>a b a a b c a b a</li>
<li>0 0 1 1 2 0 1 2 3 （PM）（这个过程肉眼看）</li>
<li>-1 0 0 1 1 2 0 1 2 （next 0 开始）（后移）</li>
<li>0 1 1 2 2 3 1 2 3（next 1 开始）（ +1 ）</li>
<li>移动位数 &#x3D; 已经匹配的字符数 - 对应的部分匹配值</li>
<li>直接移动到合适的位置</li>
<li>实际的KMP算法中，为了让公式更加简洁简单，如果串的位序是1开始，则next数组整体+1，如果位序0开始那么next数组位序不需要整体+1</li>
</ul>
</li>
<li><p>KMP算法的进一步优化 应该不考感觉</p>
<ul>
<li>nextval比的是字母 填写的是位序</li>
<li>nextval第一个位置必定是0</li>
</ul>
</li>
<li><p>综合应用题 KMP不考算法题 白了个白</p>
<ul>
<li>为了不丢失可能的匹配，右移动距离应该最小，j-k就是右移动距，k取大</li>
<li>k最大也就是意味着最大的匹配前后缀 PM</li>
<li>除了第一个字符或者有缀的情况外，主串不会素</li>
</ul>
</li>
</ul>
<h2 id="C5-树和二叉树"><a href="#C5-树和二叉树" class="headerlink" title="C5 树和二叉树"></a>C5 树和二叉树</h2><h3 id="5-1-树的概念"><a href="#5-1-树的概念" class="headerlink" title="5.1 树的概念"></a>5.1 树的概念</h3><ul>
<li>节点 n&gt;&#x3D;0 的有限集</li>
<li>多选择、也可能算法题</li>
<li>树的定义是递归的</li>
<li>树的度 孩子个数</li>
<li>双亲 兄弟</li>
<li>叶子节点、非叶节点</li>
<li>深度</li>
<li>层次</li>
<li>树的高度：最大深度</li>
<li>有序树、无序树、路径长度….</li>
<li>基本性质： ⭐️<ul>
<li>树的所有结点数 &#x3D; 每个结点度之和（总分支数）+1</li>
<li>度为m的第i层最多有m^( i-1 )</li>
<li>高度为h的m叉树最多有 xxx个结点（等比数列求和）</li>
<li>有n个结点的m叉树的最小高度：等比数列+不等式</li>
<li>总节点数n &#x3D; n0（度为0的结点）+n1+……</li>
</ul>
</li>
<li>课后习题：<ul>
<li>总节点数n &#x3D; n0（度为0的结点）+n1+……</li>
<li>其他题目根据实际情况做就行</li>
</ul>
</li>
</ul>
<h3 id="5-2-二叉树的概念"><a href="#5-2-二叉树的概念" class="headerlink" title="5.2 二叉树的概念"></a>5.2 二叉树的概念</h3><ul>
<li><p>满二叉树（每一层都满了）</p>
</li>
<li><p>完全二叉树（一层一层的完全）</p>
</li>
<li><p>二叉树的性质：</p>
<ul>
<li>n0&#x3D; n2 + 1	( n &#x3D; n0 + n1 + n2 ; n &#x3D; n1 + 2n2 )</li>
<li>k 层最多2^(k-1)结点</li>
<li>高度为h 最多2^h-1</li>
<li>完全二叉<ul>
<li>求双亲编号 &#x2F;2下取整</li>
<li>求左孩子2倍 右边孩子2n+1</li>
<li>层次高为log2n向下取整+1（log2 n+1 上取整也行）</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的存储结构</p>
<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>怪题（124个叶子的完全二叉树 最多几个结点）<ul>
<li>用巧法解出来以后查看是否可以再加一个</li>
</ul>
</li>
<li>注意题干中（任意 所有 至少 等等条件）</li>
</ul>
</li>
</ul>
<h3 id="5-3-二叉树的遍历和线索二叉树"><a href="#5-3-二叉树的遍历和线索二叉树" class="headerlink" title="5.3 二叉树的遍历和线索二叉树"></a>5.3 二叉树的遍历和线索二叉树</h3><ul>
<li><p>遍历	⭐️</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历：队列</li>
<li>先中可以确定；中后可以确定；层中可以；</li>
<li>先后、层先、层后不一定可以；</li>
</ul>
</li>
<li><p>线索二叉树</p>
<ul>
<li>ltag&#x2F;rtag 0：指向左右孩子；1：指向前&#x2F;后驱 </li>
<li>中序可以带个头节点来方便统一</li>
</ul>
</li>
<li><p>课后习题：</p>
<ul>
<li>后序可以找路径</li>
<li>线索二叉树是物理结构。。？</li>
<li>n个结点的线索二叉树上的线索数：2n</li>
<li>不是每个结点都可以通过线索直接找到前驱和后继</li>
<li>线索化后 后序线索二叉树不能通过后序线索求后序后继 </li>
<li>只有后序线索树遍历的时候需要栈的支持</li>
</ul>
</li>
<li><p>综合大题</p>
<ul>
<li>n个不同元素进栈 出栈个数C n 2n &#x2F; (n+1) </li>
<li>求一棵树的WPL 带权路径长度 给出树根结点指针<ul>
<li>可以层序遍历，也可以先序遍历</li>
<li>如果是在函数内部定义的，那么这个变量只初始化一次，即使再次调用这个函数，这个static变量也不会再次被初始化，于是，这个变量的取值就会一直保存着，我们再次调用该函数时，仍是保存的上一次函数调用时保存的结果。（static int）</li>
<li>先序遍历就多一个参数叫deep 每次把deep当成参数一起传进去 传deep+1</li>
<li>层序遍历，遍历到每层最后一个结点就加深度</li>
<li>区别于先序每一次探测都要增加深度，层序只需要在每一层最后一个元素的时候deep+1</li>
</ul>
</li>
<li>给出二叉表达式树，求中缀表达式，带括号<ul>
<li>修改中序遍历</li>
<li>空结点就直接返回</li>
<li>叶子结点就输出操作数</li>
<li>如果不是叶子那证明还要继续遍历，深度大于1就加括号，然后左边继续中序</li>
<li>然后再输出那个非叶结点的数据（操作符）</li>
<li>然后再遍历右边的东西，</li>
<li>深度大于1继续加括号（）括号对应</li>
<li>分析<ul>
<li>非叶子是操作</li>
<li>叶子是数据</li>
<li>有深度就要有括号</li>
<li>要明白 一个操作 一定涵盖了一个左边的括号和右边的括号</li>
<li>且左括号（，要把那个结点的左子树的所有操作涵盖</li>
<li>同样右括号也是这样</li>
<li>解答完毕，好题目</li>
</ul>
</li>
<li>感觉本章节内容要考的话，主要就是考在基础的遍历方式上进行一些修改</li>
<li>先匹配一个大致能完成工作的算法</li>
<li>然后分析目标和已有算法能得出的东西</li>
<li>再进行修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-4-树、森林"><a href="#5-4-树、森林" class="headerlink" title="5.4 树、森林"></a>5.4 树、森林</h3><ul>
<li><p>树的存储结构</p>
<ul>
<li>双亲表示法：一个结构体数组，分别存放着自己的data和自己的parent</li>
<li>孩子表示法：每个结点的孩子单链表起来，几个结点几个链表</li>
<li>孩子兄弟表示法：左边指针指向第一个孩子，右边指针指向了其兄弟姐妹</li>
</ul>
</li>
<li><p>树、森林与二叉树的转换 </p>
<ul>
<li>树和二叉树的对应：孩子兄弟</li>
<li>左孩子右兄弟</li>
</ul>
</li>
<li><p>树和森林的遍历	⭐️</p>
<ul>
<li><strong>树的先根遍历	对应	二叉树先序序列	对应	森林的先序遍历</strong></li>
<li><strong>树的后根遍历	对应	二叉树中序序列	对应	森林的中序遍历</strong></li>
<li><strong>记忆法：树才有根，先根先先，后根中中</strong></li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>举例子 	</li>
<li>二叉树左指针为空	-》树中叶子结点</li>
<li>二叉树右指针为空	-》树中没兄弟的结点</li>
</ul>
</li>
<li><p>综合题：</p>
<ul>
<li>非叶结点都有K个孩子，正则K叉树</li>
<li>多从数列的角度以及特殊情况的角度考虑</li>
</ul>
</li>
</ul>
<h3 id="5-5-树和二叉树的应用"><a href="#5-5-树和二叉树的应用" class="headerlink" title="5.5 树和二叉树的应用"></a>5.5 树和二叉树的应用</h3><ul>
<li><p>哈夫曼树</p>
<ul>
<li>WPL 带权路径长度</li>
<li>哈夫曼树的构造</li>
<li>哈夫曼编码（可变长度编码） </li>
<li>WPL必然相同且最优</li>
</ul>
</li>
<li><p>并查集</p>
<ul>
<li>双亲表示法</li>
<li>可用于实现克鲁斯卡尔（是否一棵树）</li>
<li>可用于判断无向图连通性</li>
<li>时间复杂度一般是最坏情况下的时间复杂度</li>
</ul>
</li>
<li><p>综合应用题      </p>
<ul>
<li>6个有序表 ABCDEF 10、35、40、50、60、200个数据元素<ul>
<li>表中升序，5次22合并，6表合一，最坏情况总次数达最小 </li>
<li>m长与n长的表合并 最多比较次数是m+n-1</li>
</ul>
</li>
<li>模拟验证前缀问题<ul>
<li>模拟</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C6-图"><a href="#C6-图" class="headerlink" title="C6 图"></a>C6 图</h2><h3 id="6-1-图的基本概念"><a href="#6-1-图的基本概念" class="headerlink" title="6.1 图的基本概念"></a>6.1 图的基本概念</h3><ul>
<li><p>顶点集 V 边集 E</p>
</li>
<li><p>图不可以是空图</p>
</li>
<li><p>有向图</p>
</li>
<li><p>无向图</p>
</li>
<li><p><strong>简单图</strong></p>
<ul>
<li>无重复遍，无自身边就</li>
<li>否则为<strong>多重图</strong></li>
</ul>
</li>
<li><p>完全图</p>
<ul>
<li>无向图与有向图的完全，没啥好说的，自己算边数吧</li>
</ul>
</li>
<li><p>子图</p>
<ul>
<li>边为子集，点为子集</li>
<li><strong>生成子图要继承所有点</strong></li>
<li>不能有边没点</li>
</ul>
</li>
<li><p>连通、连通图和连通分量</p>
<ul>
<li>无向图有边就是连通，任意2点都连通：连通图，否则非连通图</li>
<li>极大连通子图称为连通分量</li>
<li>可能没有连通分量，因为不是连通图</li>
</ul>
</li>
<li><p>强连通图、强连通分量</p>
<ul>
<li>有向图 两点有来回路径，强连通</li>
<li>有向图的极大强连通子图称为强连通分量</li>
</ul>
</li>
<li><p>生成树、生成森林</p>
<ul>
<li>连通图的生成树是包含全部顶点的极小连通子图</li>
</ul>
</li>
<li><p>顶点的度、出度、入度</p>
<ul>
<li>自己算</li>
</ul>
</li>
<li><p>边的权和网</p>
<ul>
<li>带权图称为网</li>
</ul>
</li>
<li><p>路径、路径长度和回路</p>
<ul>
<li>路径是顶点序列，边数为路径长度</li>
<li>n点 大于n-1边 铁有环</li>
</ul>
</li>
<li><p>简单路径、简单回路</p>
</li>
<li><p>距离</p>
</li>
<li><p>有向树</p>
<ul>
<li>一个点入度为0 其他点入度都是1</li>
</ul>
</li>
<li><p>课后习题：</p>
<ul>
<li>n个顶点 最少几条边 无论怎么分配都连通？ n-1点的完全图+1</li>
<li>n个顶点 最少几条边 一定有环 n-1 组合数学 一个点先和其他n-1连 然后再多一个</li>
</ul>
</li>
</ul>
<h3 id="6-2-图的存储以及基本操作"><a href="#6-2-图的存储以及基本操作" class="headerlink" title="6.2 图的存储以及基本操作"></a>6.2 图的存储以及基本操作</h3><ul>
<li><p>邻接矩阵：利于稠密图 ⭐️</p>
<ul>
<li>空间复杂度n^2</li>
<li>可以直接01</li>
<li>也可表示权</li>
<li>无向图必定唯一且对称，只需要存储上下三角</li>
<li>有向图横着是出度，竖着是入度</li>
</ul>
</li>
<li><p>邻接表法：利于稀疏图 ⭐️</p>
<ul>
<li>无向图 V + 2E</li>
<li>有向图 V + E</li>
</ul>
</li>
<li><p>邻接多重表：存无向图 感觉不考</p>
</li>
<li><p>十字链表：存有向图</p>
</li>
<li><p>课后习题：</p>
<ul>
<li>感觉都不难</li>
</ul>
</li>
<li><p>综合题：</p>
<ul>
<li>沃舍尔算法</li>
<li>浩宇考的算法</li>
</ul>
</li>
</ul>
<h3 id="6-3-图的遍历-⭐️"><a href="#6-3-图的遍历-⭐️" class="headerlink" title="6.3 图的遍历 ⭐️"></a>6.3 图的遍历 ⭐️</h3><ul>
<li><p>广搜 BFS 队列</p>
<ul>
<li>Dijkstra 单源最短路径算法</li>
<li>Prim 最小生成树算法 </li>
<li>操作：<ul>
<li>BFSTraverse</li>
<li>初始化标记数组、辅助队列</li>
<li>从0号开始遍历 即使用BFS函数 </li>
<li>BFS函数：<ul>
<li>访问初始点v</li>
<li>v入队</li>
<li>while 队列非空<ul>
<li>出队 </li>
<li>访问其所有的临界点</li>
<li>未访问的入队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>俩函数各一次</li>
<li>还可以求单源最短路径（权1）</li>
<li>广度优先生成树<ul>
<li>邻接矩阵唯一 树唯一</li>
<li>邻接表存储表示不唯一 树不唯一</li>
</ul>
</li>
<li>复杂度<ul>
<li>矩阵 V^2</li>
<li>表 V+E</li>
</ul>
</li>
</ul>
</li>
<li><p>深搜 DFS 栈</p>
<ul>
<li>DFSTraverse：<ul>
<li>初始化标记数组、辅助队列</li>
<li>从0号开始遍历 即使用DFS函数 </li>
<li>DFS函数：<ul>
<li>访问本点</li>
<li>dfs其所有的邻接点</li>
</ul>
</li>
</ul>
</li>
<li>递归动作栈 空间V</li>
<li>复杂度<ul>
<li>矩阵 V^2</li>
<li>邻接表 V+E</li>
</ul>
</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>直接秒 </li>
<li>看清有向无向图<ul>
<li>对应搜索的序列不同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-4-图的应用"><a href="#6-4-图的应用" class="headerlink" title="6.4 图的应用"></a>6.4 图的应用</h3><ul>
<li><p>最小生成树 ⭐️</p>
<ul>
<li>Prim算法（适合边稠密）<ul>
<li>每次选已知集合距离最近的点（边）</li>
<li>避开环</li>
<li>复杂度：V^2</li>
<li>记忆点：Point 与point有关</li>
</ul>
</li>
<li>Kruskal算法（适合边稀疏、顶点多）<ul>
<li>每次选边集合中最小的边</li>
<li>避开环（属于不同的连通分量）</li>
<li>复杂度 E log E</li>
</ul>
</li>
</ul>
</li>
<li><p>最短路径</p>
<ul>
<li>Dijkstra算法（单源最短路径问题）<ul>
<li>一共n个点</li>
<li>那就要进行n-1轮</li>
<li>每一轮确定到一个的最短路</li>
</ul>
</li>
<li>Floyd-Warshall算法（各顶点之间的最短路径问题）<ul>
<li>几阶矩阵 复杂度 V^3</li>
<li>矩阵乘法就行</li>
<li>允许负权边，不允许负回路</li>
</ul>
</li>
</ul>
</li>
<li><p>拓扑排序</p>
<ul>
<li>AOV网络</li>
<li>找入度为0的，然后减少那些其指向的结点的入度</li>
<li>入度数组</li>
<li>用逆邻接表更快</li>
</ul>
</li>
<li><p>关键路径</p>
<ul>
<li>AOE网络 边代表活动的网络 权值代表活动的开销 </li>
<li>ve(i)：事件Vk的最早发生时间：到本结点最长的一条路 max （列数为点数）</li>
<li>vl(i)：事件Vk的最迟发生时间：逆拓扑最小 min（列数为点数）</li>
<li>e(i)：活动Ai的最早开始时间：本活动（边）的起始点的最早发生时间（列数为边数）</li>
<li>l(i)：活动Ai的最迟开始时间：本活动（边）的终点的最迟发生时间-边长（列数为边数）</li>
<li>l(i)-e(i)：数列中0的就是关键活动</li>
</ul>
</li>
</ul>
<h2 id="C7-查找"><a href="#C7-查找" class="headerlink" title="C7 查找"></a>C7 查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><ul>
<li>查找成功和失败的平均查找长度</li>
<li>用于查找的数据集合称为查找表（同一类型的数据元素）</li>
<li>静态查找表 </li>
<li>动态查找表涉及动态插入删除</li>
<li>关键字唯一标识该元素</li>
</ul>
<h3 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h3><ul>
<li>一般线性表的顺序查找<ul>
<li>烧饼减少判断 </li>
<li>成功(n+1)&#x2F;2</li>
<li>失败n+1</li>
</ul>
</li>
<li>有序表的顺序查找<ul>
<li>成功(n+1)&#x2F;2</li>
<li>失败n&#x2F;2+n&#x2F;(n+1)</li>
<li>(1+2+….+n+n)&#x2F;(n+1)</li>
</ul>
</li>
<li>折半查找<ul>
<li>mid &#x3D; ( low + high ) &#x2F; 2 while开始就干这个</li>
<li>每一次mid与元素进行比较 移动high 和low 到mid的左右位置  </li>
<li>大小题考察概率都不低</li>
<li>不能基于链表</li>
<li>外部结点</li>
<li>判定树的画法</li>
</ul>
</li>
<li>分块查找<ul>
<li>也叫索引顺序查找<ul>
<li>可以顺序或者折半查找索引表</li>
</ul>
</li>
<li>快内无序</li>
<li>块间有序 </li>
<li>索引包含本块最大的关键字</li>
<li>最好根号n块 </li>
<li>支持链式存储，方便动态插入删除</li>
</ul>
</li>
<li>课后习题：<ul>
<li>判定树的左右取决于上下取整问题</li>
<li>哪边取整哪边少</li>
<li>排序树的性能要取决于树的形状</li>
<li>比较几次的题目就画树</li>
</ul>
</li>
</ul>
<h3 id="树型查找-⭐️"><a href="#树型查找-⭐️" class="headerlink" title="树型查找 ⭐️"></a>树型查找 ⭐️</h3><ul>
<li><p>二叉排序树 BST</p>
<ul>
<li>定义<ul>
<li>左&lt;根&lt;右	  中序就可以得到递增序列</li>
</ul>
</li>
<li>查找<ul>
<li>模拟走左右</li>
</ul>
</li>
<li>插入<ul>
<li>硬插</li>
</ul>
</li>
<li>构造<ul>
<li>从头开始插入</li>
</ul>
</li>
<li>删除 <ul>
<li>被删除的是叶子，直接删</li>
<li>被删除的结点只有左or右子树，子树代替根</li>
<li>有左右两棵树<ul>
<li>直接前驱or直接后继代替，然后继续删除那个前驱or后继</li>
<li>前驱：左子树最右下（最大）</li>
<li>后继：右子树最左下（最小）</li>
</ul>
</li>
</ul>
</li>
<li>如果有序表是动态查找表，应该用二叉排序树作为其逻辑结构</li>
</ul>
</li>
<li><p>平衡二叉树 AVL （ASL是平均查找长度）</p>
<ul>
<li>平衡因子：左高-右高 绝对值&lt;1</li>
<li>保持平衡的目的是为了查找效率</li>
<li>平衡树最少有的结点数量 nk &#x3D; nk-1 + nk-2 + 1</li>
<li>插入：调整最小不平衡子树（向上检查）<ul>
<li>LL：在A的左孩子的左子树插入导致不平衡<ul>
<li>右单旋转</li>
</ul>
</li>
<li>RR：A 右 右<ul>
<li>左单旋转</li>
</ul>
</li>
<li>LR：A 左 右<ul>
<li>先左后右 （部分左 整体右）</li>
</ul>
</li>
<li>RL：A 右 左<ul>
<li>先右后左</li>
</ul>
</li>
</ul>
</li>
<li>删除<ul>
<li>按照二叉排序树删除节点</li>
<li>向上查找问题节点 没问题就完结撒花</li>
<li>找到最小不平衡子树个头最高的儿孙<ul>
<li>根据孙子相对于爷爷的问题进行修改</li>
</ul>
</li>
<li>调整</li>
<li>查看不平衡向上传导的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>红黑树	⭐️</p>
<ul>
<li>AVL容易遭受破坏</li>
<li>平衡二叉树以查为主</li>
<li>频繁插入删除就红黑</li>
<li>定义、性质、插入</li>
<li>定义<ul>
<li>左孩子 右孩子 颜色 父亲指针 值</li>
<li>红黑树的叶子结点一般叫失败节点 NIL</li>
<li>左根右、根叶黑、不红红、黑路同<ul>
<li>BST</li>
<li>根和叶子都是黑的 </li>
<li>相邻不红</li>
<li>一个节点到任何一个叶子都是同样的黑色（不算自己）（黑高）</li>
</ul>
</li>
</ul>
</li>
<li>查找复杂 logn</li>
<li>插入：与AWL异曲同工<ul>
<li>查找、先确定插入位置</li>
<li>新节点是根就染黑，否则染红</li>
<li>破坏了就调整，要看新节点的叔叔的脸色<ul>
<li>黑叔叔：旋转+染色（看相对于爷）<ul>
<li>LL：右单、父换爷+父爷染色</li>
<li>RR：左单、父换爷+父爷染色</li>
<li>LR：左右双旋、儿换爷+染色</li>
<li>RL：右左双旋、儿换爷+染色</li>
</ul>
</li>
<li>红叔叔：染色+变新<ul>
<li>叔父爷换色，爷变新结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="B树和B-树-⭐️"><a href="#B树和B-树-⭐️" class="headerlink" title="B树和B+树 ⭐️"></a>B树和B+树 ⭐️</h3><ul>
<li><p>B树 （多路平衡查找树）</p>
<ul>
<li>性质 插入 删除</li>
<li>m叉查找树<ul>
<li>每个节点最多有m颗子树</li>
<li>最多m-1关键字</li>
<li>根如果不是终端节点，那么至少两颗子树</li>
<li>除了根以外的所有非叶子至少m&#x2F;2 上取整个子树 </li>
<li>节点内有序，有失败结点NIL（其实节点内数据多可以折半）</li>
<li>所有数据都在自己的节点</li>
</ul>
</li>
<li>所有结点子树高度相同<ul>
<li>所有叶子都在同一层</li>
</ul>
</li>
<li>计算高度不包括失败结点<ul>
<li>最小高度，填满，h&gt;&#x3D;log m (n+1) </li>
<li>最大高度，每一层结点尽可能少，h &lt;&#x3D; log m&#x2F;2 (n+1)&#x2F;2  + 1</li>
<li>log m (n+1) &lt;&#x3D; h &lt;&#x3D; log m&#x2F;2 (n+1)&#x2F;2  + 1</li>
</ul>
</li>
<li>插入<ul>
<li>先插满根、然后分裂，提出中间的位置</li>
<li>一定先插入最底层</li>
<li>插入的最关键，是学会分裂</li>
</ul>
</li>
<li>删除  <ul>
<li>删除的结点若非终端，用直接前驱or直接后继替代<ul>
<li>直接前驱，左侧指针最右</li>
<li>直接后继，右侧指针最左</li>
<li>转化成对终端节点的删除</li>
</ul>
</li>
<li>看兄弟够不够借</li>
<li>兄弟也不够<ul>
<li>合并  </li>
<li>和左右兄弟以及双亲节点中相关的关键字合并</li>
<li>可能导致双亲节点减少，向上合并</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树</p>
<ul>
<li>性质<ul>
<li>每个分支最多m个子树</li>
<li>根最少2子树，其他最少m&#x2F;2上取余个子树</li>
<li>关键字和子树个数相等</li>
<li>包含指向记录的指针</li>
<li>可以多路查找，也可以顺序查找</li>
<li>一定要走到最下层</li>
<li>关键字会重复</li>
</ul>
</li>
<li>很像分块查找</li>
<li>所有的数据都在叶子结点</li>
<li>放的是最大元素</li>
<li>并不是n个关键词，对应n+1个分支</li>
<li>对应的是n个分支，n个块，关键词存放里面最大的块</li>
<li>最下层块之间也有指针</li>
</ul>
</li>
<li><p>B+ VS B	</p>
<ul>
<li>分叉对应 </li>
<li>分支上下限，关键字上下限</li>
<li>结点重复问题</li>
<li>B+非叶只是索引，不包含存储地址</li>
<li>B包含存储地址</li>
</ul>
</li>
</ul>
<h3 id="散列表（Hash-Table）"><a href="#散列表（Hash-Table）" class="headerlink" title="散列表（Hash Table）"></a>散列表（Hash Table）</h3><ul>
<li><p>数据元素的关键字和存储地址直接相关</p>
</li>
<li><p>建立关键字和存储地址的联系</p>
</li>
<li><p>散列函数 哈希函数</p>
</li>
<li><p>散列函数的构造</p>
<ul>
<li>除留余数法 素数P<ul>
<li>均匀</li>
</ul>
</li>
<li>直接定址法<ul>
<li>空位</li>
</ul>
</li>
<li>数字分析法<ul>
<li>选数字编码分布均匀的数码位作为散列函数</li>
<li>手机后4位</li>
</ul>
</li>
<li>平方取中法<ul>
<li>平方以后中间取几位</li>
</ul>
</li>
<li>空间换时间 直接2的多少次</li>
</ul>
</li>
<li><p>处理冲突的方法</p>
<ul>
<li>开放定址法 <ul>
<li>散列表长度是4m+3素数 </li>
<li>线性探测法<ul>
<li>发生冲突、往后探测相邻的下一个单元看是否为空</li>
<li>哈希函数值域选择13 0-12</li>
<li>和冲突函数处理函数值域不一样可能 0- 15       </li>
<li>查找空也算一次查找</li>
<li>删除标记，逻辑删除，假删</li>
</ul>
</li>
<li>平方探测法<ul>
<li>1 -1 4 -4 9 -9</li>
</ul>
</li>
<li>双散列法</li>
</ul>
</li>
<li>拉链法</li>
</ul>
</li>
</ul>
<h2 id="C8-排序"><a href="#C8-排序" class="headerlink" title="C8 排序"></a>C8 排序</h2><h3 id="8-1-排序的定义"><a href="#8-1-排序的定义" class="headerlink" title="8.1 排序的定义"></a>8.1 排序的定义</h3><ul>
<li>定义</li>
</ul>
<h3 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h3><ul>
<li>直接插入排序：找一个、放前面（顺序找插入位置）</li>
<li>折半插入排序：折半找插入位置</li>
<li>希尔排序：增量、间隔</li>
</ul>
<h3 id="8-3-交换排序"><a href="#8-3-交换排序" class="headerlink" title="8.3 交换排序"></a>8.3 交换排序</h3><ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
<h3 id="8-4-选择排序"><a href="#8-4-选择排序" class="headerlink" title="8.4 选择排序"></a>8.4 选择排序</h3><ul>
<li>简单选择排序<ul>
<li>从后面选一个最小</li>
</ul>
</li>
<li>堆排序：<ul>
<li>初始：多次向上调整子树，一次向下</li>
<li>调整好后删除，最后一个元素放上来然后一次向下调整</li>
</ul>
</li>
</ul>
<h3 id="8-5-归并排序和基数排序（桶排序）"><a href="#8-5-归并排序和基数排序（桶排序）" class="headerlink" title="8.5 归并排序和基数排序（桶排序）"></a>8.5 归并排序和基数排序（桶排序）</h3><ul>
<li>归并排序<ul>
<li>分路</li>
</ul>
</li>
<li>基数排序<ul>
<li>桶</li>
</ul>
</li>
</ul>
<h3 id="8-6-各种内部排序算法的比较和应用-⭐️"><a href="#8-6-各种内部排序算法的比较和应用-⭐️" class="headerlink" title="8.6 各种内部排序算法的比较和应用 ⭐️"></a>8.6 各种内部排序算法的比较和应用 ⭐️</h3><ul>
<li>比较</li>
<li>应用</li>
</ul>
<h3 id="8-7-外部排序"><a href="#8-7-外部排序" class="headerlink" title="8.7 外部排序"></a>8.7 外部排序</h3><ul>
<li><p>概念</p>
</li>
<li><p>方法</p>
</li>
<li><p>多路平衡归并与败者树</p>
</li>
<li><p>置换-选择排序</p>
</li>
<li><p>最佳归并树</p>
<ul>
<li>x叉 n(x-1)&gt;结点数量的最小n为一共需要的结点数量</li>
<li>做差得到结果</li>
</ul>
</li>
<li><p>口诀：</p>
<ul>
<li>间希快堆（JXKD）不稳定</li>
<li>快logn 2归n 基r</li>
<li>快排平均最坏不同</li>
</ul>
</li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：408-ds</li>
        <li>Post author：Picasun</li>
        <li>Create time：2023-02-15 16:05:35</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/02/15/408-ds/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/02/15/408-net/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">408-net</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/02/15/408-cop/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">408-cop</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">Advertising space for rent ：)</div>
        <div class="page-title">408-ds</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#45%E2%80%99"><span class="nav-text">45’</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C1-%E7%BB%AA%E8%AE%BA"><span class="nav-text">C1 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">数据结构的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="nav-text">算法和算法评价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">C2 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">线性表的定义和基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="nav-text">线性表的顺序表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="nav-text">线性表的链式表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C3-%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-text">C3 栈、队列、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8-%E2%AD%90%EF%B8%8F"><span class="nav-text">栈和队列的应用 ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="nav-text">数组和特殊矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C4-%E4%B8%B2"><span class="nav-text">C4 串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">串的定义和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">串的模式匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C5-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">C5 树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">5.1 树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">5.2 二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.3 二叉树的遍历和线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="nav-text">5.4 树、森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">5.5 树和二叉树的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C6-%E5%9B%BE"><span class="nav-text">C6 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1 图的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">6.2 图的存储以及基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86-%E2%AD%90%EF%B8%8F"><span class="nav-text">6.3 图的遍历 ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">6.4 图的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C7-%E6%9F%A5%E6%89%BE"><span class="nav-text">C7 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">查找的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">顺序查找和折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE-%E2%AD%90%EF%B8%8F"><span class="nav-text">树型查找 ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91-%E2%AD%90%EF%B8%8F"><span class="nav-text">B树和B+树 ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash-Table%EF%BC%89"><span class="nav-text">散列表（Hash Table）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C8-%E6%8E%92%E5%BA%8F"><span class="nav-text">C8 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">8.1 排序的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2 插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3 交换排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.4 选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-text">8.5 归并排序和基数排序（桶排序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%92%8C%E5%BA%94%E7%94%A8-%E2%AD%90%EF%B8%8F"><span class="nav-text">8.6 各种内部排序算法的比较和应用 ⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">8.7 外部排序</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Picasun</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.1</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2022/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax defer>
                function odometer_init(){
                        let el = document.getElementsByClassName('odometer');
                        for (i = 0; i < el.length; i++) {
                            od = new Odometer({
                                el: el[i],
                                format: '( ddd).dd',
                                duration: 200
                            });
                        }
                }
                odometer_init();
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>





    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
