<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Picasun">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/02/15/408-cop/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="408-cop">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.com2023/02/15/408-cop/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Picasun&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="408-cop">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            408-cop -
        
        Picasun&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Your youth will be infinitely revived by Picasun！","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.1","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Picasun&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">408-cop</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Picasun</span>
                            
                                <span class="author-label">KatarinaQueen</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-02-15 16:05:26</span>
        <span class="mobile">2023-02-15 16:05</span>
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="45’"><a href="#45’" class="headerlink" title="45’"></a>45’</h1><h2 id="C1-计算机系统概述"><a href="#C1-计算机系统概述" class="headerlink" title="C1 计算机系统概述"></a>C1 计算机系统概述</h2><ul>
<li>针对概念或者性能指标出选择题，也可出综合性能分析题</li>
</ul>
<h3 id="计算机的发展历程-不考捏"><a href="#计算机的发展历程-不考捏" class="headerlink" title="计算机的发展历程 不考捏"></a>计算机的发展历程 不考捏</h3><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><ul>
<li><p>冯诺依曼提出“存储程序概念”，奠定了现代计算机基本结构</p>
<ul>
<li>存储程序<ul>
<li>将事先编制好的程序和数据送入主存之后才能运行，一旦程序被启动，就无须操作人员的干预，计算机自动逐条执行指令直到</li>
</ul>
</li>
<li>硬件由运算器、存储器、控制器、输入设备、输出设备 构成</li>
<li>指令和数据同等地位存储在存储器中，形式上没有区别</li>
<li>指令数据都是二进制代码表示</li>
<li>指令由操作码和地址码构成<ul>
<li>操作码指出操作类型</li>
<li>地址码指出操作数的地址</li>
</ul>
</li>
</ul>
</li>
<li><p>功能部件</p>
<ul>
<li>I&#x2F;O设备 <ul>
<li>输入设备 </li>
<li>输出设备</li>
</ul>
</li>
<li>存储器，分成内外存储器 ⭐️<ul>
<li>CPU能直接访问的叫主存储器</li>
<li>辅助存储器的内容只有调入主存才能被CPU访问 </li>
<li>主存按照存储单元的地址进行存取（地址存取方式）</li>
<li>存储体存放二进制信息，经过地址译码找到所选的单元</li>
<li>数据寄存器 MDR用于暂存要从存储器中读写信息</li>
<li>时序控制信号</li>
<li>MAR 用于寻址，对应着存储单元的个数，MAR十位，可以对应1024个存储单元 2^10</li>
<li>MAR 长度与PC相等</li>
<li>MDR与存储字长相等，一般为字节</li>
<li>他们虽然是存储器（寄存器）但也在CPU中</li>
<li>cache 也在CPU中</li>
</ul>
</li>
<li>运算器<ul>
<li>ALU 算术逻辑单元为核心 <ul>
<li>累加器 ACC</li>
<li>乘商寄存器 MQ</li>
<li>操作数寄存器 X</li>
<li>变址寄存器 IX</li>
<li>基址寄存器 BR</li>
</ul>
</li>
<li>程序状态寄存器 PSW <ul>
<li>判溢出 进位 借位 为负</li>
</ul>
</li>
</ul>
</li>
<li>控制器（指挥中心）<ul>
<li>程序计数器 PC （存放下一条指令的地址）</li>
<li>指令寄存器 IR （存放当前的指令）（内容来自的MDR）</li>
<li>控制单元 CU <ul>
<li>指令中的操作码送到CU</li>
<li>地址码送到MAR以便取操作数 （已经2次访存了）<ul>
<li>一次取指令 </li>
<li>再取操作数（不过也要看寻址方式）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CPU和主存之间通过一组总线相连，MAR地址会送到地址线，指向读写的主存单元；控制线中有读写信号线，指出操作的是读还是写；根据是读还是写来控制MDR中的数据是送到数据线上还是将数据线上的东西读到</li>
</ul>
</li>
<li><p>计算机软件	</p>
<ul>
<li>系统软件<ul>
<li>保证计算机高效、和正确运行的基础软件<ul>
<li>OS</li>
<li>DBMS</li>
<li>网络软件系统</li>
<li>标准库程序</li>
</ul>
</li>
</ul>
</li>
<li>应用软件<ul>
<li>不举例了</li>
</ul>
</li>
</ul>
</li>
<li><p>三个级别的语言</p>
<ul>
<li>机器语言<ul>
<li>二进制代码语言，计算机<strong>唯一</strong>可以直接识别并且执行的语言</li>
</ul>
</li>
<li>汇编语言 <ul>
<li>用英文单词或其缩写代替二进制的指令代码，转换成机器语言程序后才能在计算机的硬件上执行</li>
</ul>
</li>
<li>高级语言 <ul>
<li>C++ Go 方便设计人员写出解决问题的程序</li>
</ul>
</li>
</ul>
</li>
<li><p>翻译程序有三类：对应汇编器、解释器、编译器 ⭐️</p>
<ul>
<li>汇编程序：将汇编语言翻译成机器语言的程序</li>
<li>解释程序：将源程序中的语言栈执行顺序逐条翻译成机器指令并立即执行</li>
<li>编译程序：将高级语言编译成汇编语言or机器语言程序</li>
</ul>
</li>
<li><p>软硬件逻辑等价</p>
</li>
<li><p>计算机系统的工作原理</p>
<ul>
<li>“ 存储程序”工作方式<ul>
<li>执行程序前将数据和指令送入主存</li>
<li>根据PC取指令，指令译码，PC+“1”，取操作数，执行，送结果</li>
<li>周而复始</li>
</ul>
</li>
<li>从源程序到可执行文件 ⭐️<ul>
<li>编写的C语言程序被转换成一系列第几机器指令</li>
<li>指令按照可执行目标文件的格式打包，二进制存放磁盘</li>
<li>预处理：hello.c 写好 通过预处理器（cpp）将.h文件插入程序文件 变成hello.i</li>
<li>编译阶段：hello.i 通过编译器对预处理后的源程序进行编译，生成汇编语言源程序hello.s</li>
<li>汇编阶段：hello.s 被汇编器翻译成机器语言指令，并打包成可重定位目标文件的hello.o（二进制文件）</li>
<li>链接阶段：helle.o被链接器和标准库函数所在的目标模块合并，成为可执行文件hello并保存磁盘</li>
</ul>
</li>
<li>程序执行过程的描述</li>
<li>指令执行过程的描述 <ul>
<li>取指令<ul>
<li>PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IR 	 </li>
<li>PC内容送到MAR，MAR中内容直接送地址线，同时控制器将读写信号写送到读写信号线，主存根据线上的地址和读信号，从指定的存储单元读出指令，送到数据线，MDR从数据线收到指令信息，送到IR</li>
<li>简介：根据PC取指令到IR</li>
</ul>
</li>
<li>分析指令<ul>
<li>OP(IR) -&gt; CU（指令中的操作码送到CU）</li>
<li>根据IR中指令的操作码生成控制信号，送到CU</li>
<li>简介：指令译码并送出控制信号</li>
</ul>
</li>
<li>执行指令<ul>
<li>Ad(IR) -&gt; MAR -&gt; M -&gt; MDR -&gt; ACC（指令中的地址码）</li>
<li>将IR中的地址码送到MAR，MAR中的内容送到地址线，同时控制器将读信号送到读写信号线，从主存中读出操作数，通过数据线送到MDR，再送到ACC</li>
</ul>
</li>
<li>该执行的执行完，别忘（PC）+1 -&gt; PC</li>
</ul>
</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>冯诺依曼的基本工作方式：控制流驱动方式</li>
<li>冯诺依曼特点：按地址访问并顺序指令指令</li>
<li>CPU不包含指令译码器，指令译码器一般属于主存</li>
<li>MAR位数：指令中的地址码长度，存储容量等</li>
<li>MDR位数：存储字长</li>
<li>解释程序需要一遍翻译一遍运行，比较慢</li>
<li>汇编语言是用助记符来编写的</li>
<li><strong>相联存储器</strong>，是一种不根据地址而是根据存储内容来进行存取的存储器，<strong>可以实现快速地查找快表。****既可以按照地址寻址也可以按照内容寻址</strong>（通常是某些字段），为了与传统寄存器作区别，称为<strong>按内容寻址的存储器</strong>。（<strong>硬件</strong>并发查找）</li>
<li>区别指令和数据：指令周期的不同阶段</li>
</ul>
</li>
</ul>
<h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><ul>
<li><p>计算机的主要性能指标</p>
<ul>
<li>字长<ul>
<li>计算机进行一次定点数运算能处理的二进制位数</li>
<li>字长越长，精度越高，8B整数倍</li>
</ul>
</li>
<li>数据通路带宽<ul>
<li>数据总线一次能斌行传送数据的位数</li>
<li>与数据总线的宽度可能不同</li>
</ul>
</li>
<li>主存容量<ul>
<li>MAR的位数反映了存储单元的<strong>个数</strong></li>
<li>也反映了可寻址范围的最大值</li>
</ul>
</li>
<li>运算速度<ul>
<li>吞吐量和响应时间<ul>
<li>吞吐量：系统在单位时间内处理请求的数量</li>
<li>响应时间：用户向计算机发起请求，计算机多久响应，等待时间</li>
</ul>
</li>
<li>主频和CPU时钟周期<ul>
<li>主频：衡量速度的重要参数，HZ为单位，3K赫兹代表每秒3000次<ul>
<li>主频就是CPU时钟频率</li>
</ul>
</li>
<li>CPU时钟周期：1&#x2F;主频，每个指令至少1个时钟周期</li>
</ul>
</li>
<li>CPI ：执行一条指令所需要的时钟周期数</li>
<li>CPU执行时间 ：CPU时钟周期数量&#x2F;主频&#x3D;（指令条数xCPI）&#x2F;主频</li>
<li>MIPS：每秒执行多少百万条指令</li>
<li>更多指标<ul>
<li>MFLOPS：每秒多少百万次浮点数运算 10^6</li>
<li>GFLOPS：每秒执行多少十亿次浮点数运算 10^9</li>
<li>TFLOPS：每秒执行多少万亿次浮点数运算 10^12</li>
<li>PFLOPS：10^15</li>
<li>EFLOPS：10^18</li>
<li>ZFLOPS；10^21</li>
</ul>
</li>
<li>基准程序		<ul>
<li>用于进行性能评价的一组程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>几个专业术语</p>
<ul>
<li>系列机：指令系统相同，型号不同</li>
<li>兼容：软硬件的通用性</li>
<li>可移植性：软件进行很少的修改可以运行在另一个系列计算机的可能性</li>
<li>固件：将程序固化在ROM中存成的部件称为古剑，有软件特性的硬件，快于软件，灵活于硬件，软硬件结合的产物，目前操作系统已经实现了部分固化，软件永恒存储于ROM中。</li>
</ul>
</li>
<li><p>课后习题</p>
<ul>
<li>寄存器由触发器构成</li>
<li>存储字长、指令字长、机器字长的讨论 ⭐️<ul>
<li>存储字长：一个存储单元存储一串二进制代码的位数</li>
<li>指令字长：机器指令中二进制代码的总位数，指令字长取决于从操作码的长度、操作数地址的长度和操作数地址的个数。不同的指令的字长是不同的</li>
<li>机器字长：计算机进行一次整数运算所能处理的二进制数据的位数<ul>
<li>机器字长也是用于整数运算的数据通路的宽度 </li>
<li>一定与机器字长相同的是 <ul>
<li>ALU 通用寄存器</li>
</ul>
</li>
</ul>
</li>
<li>举个例子，如果主存容量4GB，一个字是32位（4B），按字寻址，那么存储字长就是32B，指令字长中的地址码就是30位（4GB&#x2F;4B&#x3D;2^30个）</li>
</ul>
</li>
<li>对用户透明（看不见）：⭐️<ul>
<li>指令寄存器 </li>
<li>IR、MAR、MDR等CPU内部工作寄存器</li>
</ul>
</li>
<li>对用户不透明（看得见）：<ul>
<li>程序寄存器、状态寄存器、通用寄存器（汇编程序员可见）</li>
</ul>
</li>
<li>CPU 的CPI与时钟频率无关 废话 一个是程序的特点 一个是CPU特点</li>
<li>高性能计算机的主要技术是并行技术</li>
<li>决定计算机精度的主要指标是字长</li>
<li>操作系统命令 不等于 指令</li>
</ul>
</li>
<li><p>综合应用题：</p>
<ul>
<li>指出位数 信息通路</li>
<li>求CPI MIPS速率 和程序执行时间<ul>
<li>CPI一般是数学期望</li>
<li>MIPS就是时钟频率&#x2F;CPI （MIPS：每秒执行多少百万条指令）</li>
<li>时钟频率就是每秒包含的CPU时钟数量 </li>
<li>程序执行时间一般是CPI x I（总共指令数）x 一个CPU时钟的长度</li>
</ul>
</li>
<li>求CPU时钟周期、求平均指令周期、求平均执行速度MIPS</li>
<li>主频高的CPU不一定比主频低的CPU快，CPU流水线其他的指标也应该纳入考虑。</li>
</ul>
</li>
<li><p>本章节的二轮学习透彻了很多，很多第一轮没有搞懂的知识也一点点熟悉了起来</p>
</li>
</ul>
<h2 id="C2-数据的表示和运算"><a href="#C2-数据的表示和运算" class="headerlink" title="C2 数据的表示和运算"></a>C2 数据的表示和运算</h2><ul>
<li><p>数值和编码</p>
<ul>
<li>原码、反码、补码、移码<ul>
<li>原	0不唯一<ul>
<li>+1010	00001010</li>
<li>-1010  10001010</li>
</ul>
</li>
<li>补	0唯一<ul>
<li>+1010 00001010</li>
<li>-1010 10000110</li>
</ul>
</li>
<li>反 0不唯一</li>
<li>移 0唯一<ul>
<li>直接移动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>运算方法和电路</p>
<ul>
<li>异或门（一个圆圈一个加号）<ul>
<li>不一样就1 一样就0</li>
</ul>
</li>
</ul>
</li>
<li><p>PSW的标志 ⭐️</p>
<ul>
<li>溢出标志OF 1溢出</li>
<li>符号标志SF 1负</li>
<li>零标志ZF 0为1</li>
<li>借or进位标志CF 借进1</li>
</ul>
</li>
<li><p>移动位置补的规则</p>
<ul>
<li>负补 左0右1</li>
</ul>
</li>
<li><p>定点数加减法</p>
<ul>
<li>补就正常的补</li>
</ul>
</li>
<li><p>定点数乘除法（伏笔）</p>
</li>
<li><p>习题：</p>
<ul>
<li>32：负补码 补位置 添加1 </li>
<li>33：溢出的判断用十进制简单</li>
<li>34：大端是符合我们人类的方式<ul>
<li>边界对齐：起始地址&#x2F;自身长度（字节）整除</li>
</ul>
</li>
<li>35：我会</li>
<li>36：负补 左0右1（双符号位判断：01上溢 10下溢出）</li>
<li>37：真值一眼</li>
<li>38：补码变成无符号数</li>
<li>39：小端存储</li>
<li>40：真值</li>
<li>41：小端+补码</li>
<li>42：**逻辑左右移 都补0 **<ul>
<li>**补码算数移动，符号不移动，右移动补符号位，左边0 **</li>
</ul>
</li>
<li>43：借位 溢出</li>
<li>44：数值转换（类型）</li>
<li>45：边界对齐+小端</li>
</ul>
</li>
<li><p>08-2020、02-2011（伏笔）</p>
</li>
<li><p>浮点数的表示</p>
<ul>
<li>数符S</li>
<li>阶码E（不能全1or全0）</li>
<li>尾数M</li>
<li>1 8 23 32位单精度</li>
<li>1 11 52 64位双精度</li>
</ul>
</li>
<li><p>加减：（需要再看一下视频的）</p>
<ul>
<li>对阶：小向大看齐</li>
<li>尾数求和</li>
<li>规格化 </li>
<li>舍入</li>
<li>溢出判断</li>
</ul>
</li>
<li><p>课后习题：</p>
<ul>
<li>23 浮点数相加减</li>
</ul>
</li>
</ul>
<h2 id="C3-存储系统"><a href="#C3-存储系统" class="headerlink" title="C3 存储系统"></a>C3 存储系统</h2><h3 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h3><ul>
<li><p>作用分类</p>
<ul>
<li>主存储器（可以和辅助存储器和Cache交换数据）</li>
<li>辅助存储器（暂时不用的程序和数据）</li>
<li>高速缓冲存储器（主存CPU之间，存放常用的指令和数据）</li>
</ul>
</li>
<li><p>存储介质分类</p>
<ul>
<li>磁表面存储器</li>
<li>磁芯存储器</li>
<li>半导体存储器</li>
<li>光盘存储器</li>
</ul>
</li>
<li><p>存取方式分类⭐️</p>
<ul>
<li>随机存储器RAM：随机存起，时间和位置无关<ul>
<li>静态RAM</li>
<li>动态RAM</li>
</ul>
</li>
<li>只读存储器ROM<ul>
<li>只能随机读出而不能写入</li>
</ul>
</li>
<li>串行访问存储器<ul>
<li>顺序存取存储器&#x2F;直接存取存储器</li>
<li>DAM 主存存取存储器</li>
<li>SAM 顺序存取存储器</li>
</ul>
</li>
</ul>
</li>
<li><p>可保存</p>
<ul>
<li>易失性存储器 </li>
<li>非易失性存储器      </li>
<li>破坏性读出（需要再生操作）or非破坏性读出</li>
</ul>
</li>
<li><p>性能指标</p>
<ul>
<li>存储容量&#x3D;存储字数x字长</li>
<li>单位成本</li>
<li>存储速度：数据传输率&#x3D;数据宽度&#x2F;存储周期<ul>
<li>存取时间Ta（启动存储器到完成操作的时间）<ul>
<li>读出时间和写入时间</li>
</ul>
</li>
<li>存取周期Tm（连续两次独立访问存储器的操作之间需要最小时间间隔）</li>
<li>主存带宽Bm</li>
</ul>
<p>	   </p>
</li>
<li>对于任何一种存储器，读写以后需要一段时间回复内部状态</li>
<li>破坏性存储周期比存取时间打的多，因为读出需要再生</li>
</ul>
</li>
<li><p>多层次存储系统</p>
<ul>
<li>Cache 主存 硬件and速度趋近于Cache</li>
<li>主存 辅存 OS+硬件and速度趋近于主存<ul>
<li>逐渐形成了虚拟存储系统，编程可用地址空间远大于主存</li>
</ul>
</li>
<li>上层是下层副本</li>
</ul>
</li>
<li><p>课后习题：</p>
<ul>
<li><strong>相联存储器是按照内容制定方式和地址指定方式相结合</strong></li>
</ul>
</li>
</ul>
<h3 id="3-2-主存储器"><a href="#3-2-主存储器" class="headerlink" title="3.2 主存储器"></a>3.2 主存储器</h3><ul>
<li><p>易失⭐️</p>
<ul>
<li>主存：<strong>DRAM</strong><ul>
<li>栅极电容</li>
<li>信息会自动消失，需要刷新 2ms<ul>
<li>集中刷新：死时间</li>
<li>分散刷新：降速</li>
<li>异步刷新：死时间</li>
</ul>
</li>
<li><strong>破坏性</strong>读出，需要再生</li>
<li>行列地址分两次送（减少选通线数量）</li>
<li>现在常用SDRAM</li>
</ul>
</li>
<li>Cache：<strong>SRAM</strong><ul>
<li>双稳态触发器，MOS</li>
<li><strong>非破</strong></li>
<li>快</li>
<li>行列地址同时送</li>
</ul>
</li>
</ul>
</li>
<li><p>非易（断电不G）⭐️</p>
<ul>
<li><strong>ROM</strong> 只读<ul>
<li>MROM</li>
<li>PROM</li>
<li>EPROM<ul>
<li>可擦除可编程</li>
<li>EEPROM</li>
<li>UVEPROM</li>
</ul>
</li>
<li>闪存（U盘）（基于EEPROM）<ul>
<li>快速可擦除重写</li>
</ul>
</li>
<li>SSD</li>
</ul>
</li>
</ul>
</li>
<li><p>SRAM与DRAM</p>
<ul>
<li>P88</li>
</ul>
</li>
<li><p>BIOS芯片（ROM、里面有自举装入程序）+内存条 就是主存</p>
<ul>
<li>逻辑上主存由RAM和ROM组成，统一编址</li>
</ul>
</li>
<li><p>双端口RAM</p>
<ul>
<li>同时读&#x2F;写不同</li>
<li>可同时读同</li>
<li>不能同时读or写同</li>
</ul>
</li>
<li><p>多体并行存储器⭐️</p>
<ul>
<li>可以理解为多体并行</li>
<li>体号+体内地址</li>
<li>高&#x2F;低位交叉编址的多体存储器<ul>
<li>T&#x3D;4r </li>
<li>高 1 8 16 24（需要5T读5个）（单纯扩容）</li>
<li>低 1 2 3 4 （T+（n-1）r）好！！ n无穷趋近r（双通道）</li>
</ul>
</li>
<li>实际应用的情况下需要连续访问 </li>
<li>存取流水线<ul>
<li>存取周期为T，存取时间为r</li>
<li>交叉模块数应该m&#x3D;&gt;T&#x2F;r</li>
</ul>
</li>
<li>体号判断存储体<ul>
<li>根据x%m</li>
</ul>
</li>
<li>体块独立</li>
</ul>
</li>
<li><p>单体多字</p>
<ul>
<li>会读多余的信息</li>
<li>灵活性差</li>
<li>速度不会慢很多</li>
</ul>
</li>
<li><p>课后习题：</p>
<ul>
<li>行列通选线、读写控制线</li>
<li>电源线 接地线 DRAM地址引脚服用激素后</li>
<li>半导体一次完整刷新过程需要占用一个存储周期（读出又存回） </li>
<li>刷新放大集成在RAM</li>
<li>RAM和ROM都可以随机存取（只读概念没有被保留 可以电擦除等方式写入）</li>
</ul>
</li>
</ul>
<h3 id="3-3-主存储器与CPU的连接"><a href="#3-3-主存储器与CPU的连接" class="headerlink" title="3.3 主存储器与CPU的连接"></a>3.3 主存储器与CPU的连接</h3><ul>
<li><p>连接原理</p>
<ul>
<li><strong>数据总线宽度&#x3D;存储字长</strong> </li>
<li>CPU包含MARMDR</li>
<li>通过数据总线	地址总线	控制线和主存沟通</li>
<li>地址线A</li>
<li>数据线D</li>
<li>片选CS （注意高低点平 有可能CE）</li>
<li>读写WEorWR（加了一 低写高读）write enable</li>
</ul>
</li>
<li><p>容量扩展 ⭐️</p>
<ul>
<li>容量&#x3D;字x位 </li>
<li>利用译码片选法（而不是线选，因为更多地址，地址连续）</li>
<li>位扩展（数据总线传送能力得以发挥）<ul>
<li>8Kx1位 8个 （8K个单元）</li>
<li>8Kx8位  </li>
<li>每次是都选中的</li>
</ul>
</li>
<li>字扩展（更好利用CPU寻址能力）<ul>
<li>需要译码器来片选</li>
</ul>
</li>
<li>字位扩展</li>
<li>CPU先往地址线送电流，稳定了再使能译码器，然后片选</li>
</ul>
</li>
<li><p>习题：</p>
<ul>
<li>位扩展不影响地址的计算</li>
<li>字位扩展题 体号+体内地址</li>
<li><strong>MAR位数</strong>直接决定了主存空间的大小</li>
<li>但是主存空间大小不能反应位数</li>
</ul>
</li>
</ul>
<h3 id="3-4-外部存储器"><a href="#3-4-外部存储器" class="headerlink" title="3.4 外部存储器"></a>3.4 外部存储器</h3><ul>
<li>磁盘存储器（控制器标准 ATA SATA）<ul>
<li>容量大、价格低</li>
<li>重复使用</li>
<li>长期保存不丢失、脱机 存放</li>
<li>非破坏性读出</li>
</ul>
</li>
<li>组成<ul>
<li>磁头数 </li>
<li>柱面数</li>
<li>扇区数  （以扇区为单位读写）</li>
</ul>
</li>
<li>性能指标<ul>
<li>格式化&lt;非格式化容量</li>
<li>记录密度<ul>
<li>道密度</li>
<li>位密度：单位长度二进制代码位数，越内磁道密度越大</li>
<li>面密度为乘积</li>
</ul>
</li>
<li>存取时间<ul>
<li>寻道+旋转（半圈）+传输</li>
</ul>
</li>
</ul>
</li>
<li>如何指明<ul>
<li>磁盘地址：驱动器号、柱面号、盘面号、扇区号</li>
</ul>
</li>
<li>磁盘阵列<ul>
<li>逻辑相邻物理不同方便读取</li>
<li>RAID0：无冗余无校验</li>
<li>RAID1：镜像磁盘阵列</li>
<li>RAID2：海明码</li>
<li>RAID3：位交叉奇偶</li>
<li>RAID4：块交叉奇偶</li>
<li>RAID5：无独立校验奇偶</li>
</ul>
</li>
<li>SSD<ul>
<li>基于闪存技术</li>
<li>扇区&#x2F;块为读取最小单位 </li>
<li>读快随机写很慢</li>
<li>读写性能高于磁盘</li>
<li>以页为单位读写 相当于磁盘的一个块（扇区）</li>
<li>以块为单位擦除</li>
<li>SSD的一个块相当于一个磁道</li>
<li>闪存翻译层负责翻译逻辑块号找到对应页（映射）</li>
<li>容易磨损（引入磨损均衡技术）</li>
</ul>
</li>
<li>课后习题：<ul>
<li>访盘时间&#x3D;控制器延迟+平均寻道+平均旋转（半圈）+传输⭐️</li>
<li>扇区中包含数据、地址和校验等信息</li>
<li>RAID 考了一次</li>
</ul>
</li>
</ul>
<h3 id="3-5-高速缓冲存储器Cache⭐️"><a href="#3-5-高速缓冲存储器Cache⭐️" class="headerlink" title="3.5 高速缓冲存储器Cache	⭐️"></a>3.5 高速缓冲存储器Cache	⭐️</h3><ul>
<li><p>局部性原理</p>
</li>
<li><p>Cache基本工作原理</p>
</li>
<li><p>计算命中率</p>
</li>
<li><p>计算平均访问时间</p>
</li>
<li><p>主存存储空间分块，主存和Cache以块为单位进行数据交换</p>
</li>
<li><p>主存的块也被称为一个页&#x2F;页面&#x2F;页框</p>
</li>
<li><p>cache中的块也称为行</p>
</li>
<li><p>问题</p>
<ul>
<li>如何区分Cache和主存数据块的对应关系（映射方法）</li>
<li>Cache满了怎么办（替换算法）</li>
<li>CPU改了Cache 主存如何一致性？（Cache写策略）</li>
</ul>
</li>
<li><p>cache和主存的映射方法（都叫块号 方便）</p>
<ul>
<li>每个Cache加一个标记、用标记记录对应的主存块号</li>
<li>用<strong>有效位</strong>来决定有效与否 </li>
<li>全相联映射（主存快可以放在Cache任意位置）<ul>
<li>命中率高，查找标记慢</li>
</ul>
</li>
<li>直接映射（Cache快号&#x3D;主存快号%cache总快数）<ul>
<li>速度最快，只比较一个，但是cache存储空间利用不充分</li>
</ul>
</li>
<li>组相连映射（组号&#x3D;主存块号%分组数）<ul>
<li>折中 综合好</li>
</ul>
</li>
<li>先要对内存分块：主存块号+块内地址</li>
<li>然后看映射方法：每一组里有几个数据，对应标记位置有几位</li>
</ul>
</li>
<li><p>替换算法</p>
<ul>
<li>全相联：cache满了才替换</li>
<li>直接映射：直接替换</li>
<li>组相连：组满了替换</li>
<li>RAND随机算法</li>
<li>FIFO先进先出算法</li>
<li>LRU近期最少使用（OS中 LRU 最近最久未使用置换算法）一样 ⭐️<ul>
<li>计算机的实现使用计数器，Cache满了以后替换计数器最大的</li>
<li>命中时所命中的清0 <strong>比他低的计数器+1</strong>（计数器值低）</li>
<li>未命中有空闲，新装的为0，其他非空闲加1</li>
<li>未命中无空闲，最大的被淘汰，新为0，其他+1</li>
<li>硬件实现需要冗余信息</li>
<li>频繁访问的值大于cache行的数量，很容易抖动</li>
</ul>
</li>
<li>LFU最不经常使用<ul>
<li>计数器替换计数器值最小的（一样就FIFO 或者行号小的滚蛋）</li>
<li>新的块计数器0 每访问一次就1 </li>
<li>经常被访问 未来不一定用得到 实际不好</li>
</ul>
</li>
<li>抖动：刚换出又被访问</li>
</ul>
</li>
<li><p>cache写策略（保持一致性）</p>
<ul>
<li>写命中<ul>
<li>写回法<ul>
<li>CPU对Cache写命中，只修改Cache内容，不立即写入主存</li>
<li>换出写回、需要脏位（数据不一致）</li>
</ul>
</li>
<li>全写法<ul>
<li>CPU对Cache写命中，cache和主存一起写</li>
<li>使用写缓冲（write buffer SRAM FIFO 写SRAM很快 控制电路写回内存）</li>
<li>可能缓冲饱和发生阻塞</li>
</ul>
</li>
</ul>
</li>
<li>写不命中<ul>
<li>写分配法<ul>
<li>先把内存快调入cache，然后配合写回法</li>
</ul>
</li>
<li>非写分配法（配合全写法）<ul>
<li>直接写主存</li>
</ul>
</li>
</ul>
</li>
<li>多级别cache L1 L2 L3</li>
</ul>
</li>
<li><p>习题：（伏笔啊伏笔）07 09</p>
<ul>
<li>时间局部性：一条指令一旦执行，接下来可能再执行</li>
<li>空间局部性：一个存储单元背访问，他附近的很多单元也很快被访问</li>
</ul>
</li>
</ul>
<h3 id="3-6-虚拟存储器"><a href="#3-6-虚拟存储器" class="headerlink" title="3.6 虚拟存储器"></a>3.6 虚拟存储器</h3><ul>
<li><p>一点回忆</p>
<ul>
<li>cache和主存用块交换数据</li>
<li>一个进程在逻辑上被分为若干个大小相等的页面，每个页面可以离散放入不同的主存块</li>
<li>通过页表找到在内存中的位置</li>
<li>快表SRAM 相联存储器 可以通过内容 </li>
<li>主存DRAM</li>
<li>快表有页表项副本</li>
<li>cache中有主存块副本</li>
</ul>
</li>
<li><p>虚拟存储器的基本概念</p>
<ul>
<li>给予了好像更大的内存空间</li>
</ul>
</li>
<li><p>页式虚拟存储器</p>
</li>
<li><p>段式虚拟存储器</p>
</li>
<li><p>段页式虚拟存储器</p>
</li>
<li><p>虚拟存储器与Cache的比较</p>
</li>
<li><p>课后习题：</p>
<ul>
<li>cache是主存的副本</li>
<li>TLB是页表的副本</li>
<li>是否已经调入主存<ul>
<li>找寻一个东西，先从TLB找映射</li>
<li>再从page找映射</li>
</ul>
</li>
<li>取数、处理 <ul>
<li>再在cache找是否有</li>
<li>再在主存里找</li>
</ul>
</li>
<li>TLB 页表 cache 主存（命令组合访存过程 有虚拟地址的情况下） ⭐️（10）</li>
</ul>
</li>
<li><p>主存中包含的东西</p>
<ul>
<li>地址译码器（务必记住不是包含在CPU）</li>
</ul>
</li>
<li><p>指令</p>
<ul>
<li>是计算机运行的最小功能单位 </li>
<li>操作码：干什么</li>
<li>地址码：干谁</li>
<li>最后一条指令的操作码是停机，地址码没啥吊用</li>
</ul>
</li>
<li><p>指令（机器指令 所有指令的集合称为指令系统、指令集）</p>
<ul>
<li>根据地址码数目不同分类<ul>
<li>0地址指令：OP<ul>
<li>不需要操作数、关中断、停机</li>
<li>堆栈计算机，两个操作数隐含在栈顶和次栈顶，结果压栈</li>
</ul>
</li>
<li>1地址指令：OP+A1<ul>
<li>只要一个操作数（+-1、取反、求补）</li>
<li>需要两个操作数，一个隐含某个寄存器、比如ACC、</li>
</ul>
</li>
<li>2地址指令：OP+A1+A2（操作+目的+源）<ul>
<li>用于需要2个操作数的算术运算、逻辑运算等</li>
</ul>
</li>
<li>3地址指令：OP+A1+A2+A3<ul>
<li>需要两个操作数的算数运算、逻辑运算等</li>
</ul>
<p> 	</p>
</li>
<li>4地址指令：OP+A1+A2+A3+A4（加的是下址）<ul>
<li>PC改为A4</li>
</ul>
</li>
<li>PS：取指令访存、取数访存、存数访存</li>
<li>位数越长，地址码数量越多，寻址能力越差（能力看一个个的位数）</li>
</ul>
</li>
<li>根据指令长度分类 ⭐️⭐️<ul>
<li>要点<ul>
<li>指令字长：指令总长度（可能会变）</li>
<li>机器字长：一次整数运算能处理的二进制数据的位数</li>
<li>存储字长：一个存储单元中二进制代码位（MDR）</li>
<li>定长指令字结构：所有指令长度相等</li>
<li>变长指令字结构：各种指令长度不等</li>
</ul>
</li>
</ul>
</li>
<li>根据操作码长度不同分类<ul>
<li>定长操作码：译码电路简单，灵活性差</li>
<li>可变长操作码 ：相反</li>
<li>定长指令字结构+可变长操作码：扩展操作码指令格式⭐️</li>
</ul>
</li>
<li>根据操作类型分类 <ul>
<li>数据传送LOAD</li>
<li>算术逻辑操作<ul>
<li>算数、逻辑</li>
</ul>
</li>
<li>移位操作：算术移位、逻辑移位、循环移位</li>
<li>转移操作JMP、JZ、CALL、RETURN、TRAP </li>
<li>输入输出操作</li>
</ul>
</li>
</ul>
</li>
<li><p>扩展操作码指令格式	</p>
<ul>
<li>不允许短是长的前缀 </li>
<li>操作码不能重复</li>
<li>频率更高，操作码越短最好</li>
<li>4_1_2</li>
</ul>
</li>
</ul>
<h2 id="C4-指令系统"><a href="#C4-指令系统" class="headerlink" title="C4 指令系统"></a>C4 指令系统</h2><h3 id="4-1-指令格式"><a href="#4-1-指令格式" class="headerlink" title="4.1 指令格式"></a>4.1 指令格式</h3><ul>
<li>指令<ul>
<li>是计算机运行的最小功能单位 </li>
<li>操作码：干什么</li>
<li>地址码：干谁</li>
<li>最后一条指令的操作码是停机，地址码没啥吊用</li>
</ul>
</li>
<li>指令（机器指令 所有指令的集合称为指令系统、指令集）<ul>
<li>根据地址码数目不同分类<ul>
<li>0地址指令：OP<ul>
<li>不需要操作数、关中断、停机</li>
<li>堆栈计算机，两个操作数隐含在栈顶和次栈顶，结果压栈</li>
</ul>
</li>
<li>1地址指令：OP+A1<ul>
<li>只要一个操作数（+-1、取反、求补）</li>
<li>需要两个操作数，一个隐含某个寄存器、比如ACC、</li>
</ul>
</li>
<li>2地址指令：OP+A1+A2（操作+目的+源）<ul>
<li>用于需要2个操作数的算术运算、逻辑运算等</li>
</ul>
</li>
<li>3地址指令：OP+A1+A2+A3<ul>
<li>需要两个操作数的算数运算、逻辑运算等</li>
</ul>
<p> 	</p>
</li>
<li>4地址指令：OP+A1+A2+A3+A4（加的是下址）<ul>
<li>PC改为A4</li>
</ul>
</li>
<li>PS：取指令访存、取数访存、存数访存</li>
<li>位数越长，地址码数量越多，寻址能力越差（能力看一个个的位数）</li>
</ul>
</li>
<li>根据指令长度分类 ⭐️⭐️<ul>
<li>要点<ul>
<li>指令字长：指令总长度（可能会变）</li>
<li>机器字长：一次整数运算能处理的二进制数据的位数</li>
<li>存储字长：一个存储单元中二进制代码位（MDR）</li>
<li>定长指令字结构：所有指令长度相等</li>
<li>变长指令字结构：各种指令长度不等</li>
</ul>
</li>
</ul>
</li>
<li>根据操作码长度不同分类<ul>
<li>定长操作码：译码电路简单，灵活性差</li>
<li>可变长操作码 ：相反</li>
<li>定长指令字结构+可变长操作码：扩展操作码指令格式⭐️</li>
</ul>
</li>
<li>根据操作类型分类 <ul>
<li>数据传送LOAD</li>
<li>算术逻辑操作<ul>
<li>算数、逻辑</li>
</ul>
</li>
<li>移位操作：算术移位、逻辑移位、循环移位</li>
<li>转移操作JMP、JZ、CALL、RETURN、TRAP </li>
<li>输入输出操作</li>
</ul>
</li>
</ul>
</li>
<li>扩展操作码指令格式	<ul>
<li>不允许短是长的前缀 </li>
<li>操作码不能重复</li>
<li>频率更高，操作码越短最好</li>
<li>4_1_2</li>
</ul>
</li>
</ul>
<h3 id="4-2-指令的寻址方式⭐️（如何确定下一条指令的存放地址）"><a href="#4-2-指令的寻址方式⭐️（如何确定下一条指令的存放地址）" class="headerlink" title="4.2 指令的寻址方式⭐️（如何确定下一条指令的存放地址）"></a>4.2 指令的寻址方式⭐️（如何确定下一条指令的存放地址）</h3><ul>
<li>计算机的工作过程<ul>
<li>PC程序计数器+“1”（这个1由编址方式，一个指令字长决定）</li>
<li>指令寻址是为了找到下一跳将执行指令的地址</li>
<li>始终由程序计数器PC给出下一条指令的地址⭐️</li>
</ul>
</li>
<li>CPU先读入指令的第一个字来判断几地址指令，来确定指令占几个字节<ul>
<li>接着修改CPU的值</li>
<li>（PC）+ n -&gt; PC（<strong>顺序寻址</strong>）n为本条指令长度</li>
<li>每次读一个字 都需要一次访存（伏笔）</li>
<li>如果指令三个字，取指令都要三次？（伏笔）</li>
</ul>
</li>
<li><strong>跳跃寻址</strong><ul>
<li>转移指令给出地址，放到PC</li>
<li>PC先自动+1 然后无条件转移7</li>
</ul>
</li>
<li>指令寻址：顺序or跳跃</li>
<li>常见的数据寻址方式 ⭐️（确定本条指令的地址码指明的真实地址）<ul>
<li>在地址码（形式地址）之前需要有一个字段标志寻址特征</li>
<li>求出操作时的真实地址称为有效地址（EA）</li>
<li><strong>直接寻址</strong>：<ul>
<li>指令字中的形式地址A就是EA </li>
<li>取指令1次访存，执行指令1次访存</li>
<li>操作数地址不易修改、灵活性差</li>
<li>寻址范围受地址长度限制</li>
</ul>
</li>
<li><strong>立即寻址</strong><ul>
<li>显式写在指令中（立即数） </li>
<li>特征是#</li>
<li>立即数的范围收到位数限制</li>
</ul>
</li>
<li><strong>间接寻址</strong>：（一次）<ul>
<li>形式地址中存放的地址是EA</li>
<li>取指令1次访存，执行指令2次访存</li>
<li>EA&#x3D;（A）</li>
<li>二次间址EA&#x3D;（（A））：方便编程，互相调用</li>
<li>可以扩大寻址范围，范围受存储字长限制</li>
<li>便于编制程序，但多次访存，效率低</li>
</ul>
</li>
<li><strong>寄存器寻址</strong>：<ul>
<li>地址码指向了某个寄存器的编号</li>
<li>寄存器里存放了<strong>操作数</strong></li>
<li>1次访存</li>
<li>指令字短、执行快但贵</li>
</ul>
</li>
<li><strong>寄存器间接寻址</strong>：<ul>
<li>寄存器里放的东西是EA</li>
<li>EA&#x3D;（Ri）</li>
<li>比一般间接寻址更快</li>
<li>2次访存</li>
</ul>
</li>
<li><strong>隐含寻址</strong>：<ul>
<li>指令中隐含操作数的地址</li>
<li>指明了一个操作数的地址、另一个可能在ACC里</li>
<li>利于缩短字长、需要增加存储操作数或者隐含地址的硬件</li>
</ul>
</li>
<li><strong>偏移寻址</strong> 区别在于偏移的<strong>起点</strong>不一样 ⭐️ 这些在执行期间都1次访存捏<ul>
<li><strong>基址寻址</strong>（程序的起始存放地址作为起点）<ul>
<li>EA&#x3D;（BR）+A</li>
<li>BR是基址寄存器、就是OS中的重定位寄存器</li>
<li>BR可以由通用寄存器代替</li>
<li>指明寄存器的位数要看有几个寄存器</li>
<li>便于<strong>整个程序程序浮动</strong>、方便<strong>多道程序并发执行</strong></li>
<li>基址寄存器的值放在PCB，面向OS，由操作系统或者管理程序决定</li>
<li><strong>程序员看不见基址寄存器捏</strong></li>
<li>程序员可用汇编语言直接操作<strong>通用寄存器</strong>（如果没被定为基址寄存器）</li>
</ul>
</li>
<li><strong>变址寻址</strong>（程序员自己决定哪里作为起点）<ul>
<li>EA&#x3D;（IX）+A </li>
<li>IX是变址寄存器，可能是专门，可能是通用</li>
<li>IX面向用户，基址寄存器中的由OS管理</li>
<li>适合<strong>循环程序</strong></li>
<li>A作为基地址</li>
<li>（IX）作为<strong>偏移量</strong></li>
<li>（IX）作为指针不断变大，偏移量是会改动的</li>
</ul>
</li>
<li><strong>相对寻址</strong>（以PC所指的地址作为起点）<ul>
<li>EA&#x3D;（PC）+A </li>
<li>（PC）基地址</li>
<li>A作为偏移量，补码表示，可正可负</li>
<li>可以前后偏移，方便<strong>转移指令、程序内部浮动</strong></li>
<li><strong>A是相对于下一条指令地址的位移量</strong></li>
<li>挪动一个循环的位置</li>
<li>分开程序与数据段，这样段内相对位置一定不变</li>
</ul>
</li>
</ul>
</li>
<li>堆栈寻址<ul>
<li>操作数放在堆栈中，隐含使用<strong>堆栈指针SP</strong>作为操作数地址</li>
<li>SP：Stack Pointer</li>
<li>放在寄存器里  </li>
<li>寄存器堆栈（硬堆栈）（快、贵、不用访存）<ul>
<li>R0 R1 R2 R3 </li>
<li>顶为0 底为3</li>
<li>因此弹出后要（SP）+1 -&gt; SP</li>
</ul>
</li>
</ul>
</li>
<li>主存划分堆栈（软堆栈）（偏移、实际）</li>
</ul>
</li>
</ul>
<h3 id="4-3-程序的机器级代码表示"><a href="#4-3-程序的机器级代码表示" class="headerlink" title="4.3 程序的机器级代码表示"></a>4.3 程序的机器级代码表示</h3><p>先PASS（伏笔）</p>
<h3 id="4-4-CISC和RISC的基本概念"><a href="#4-4-CISC和RISC的基本概念" class="headerlink" title="4.4 CISC和RISC的基本概念"></a>4.4 CISC和RISC的基本概念</h3><ul>
<li>指令系统<ul>
<li><p>指令格式：如何用二进制代码表示指令</p>
</li>
<li><p>指令寻址方式：</p>
<ul>
<li>给出下一条指令的地址</li>
<li>给出要操作的对象的地址</li>
</ul>
</li>
<li><p>CISC&amp;RISC：两种设计方向</p>
<ul>
<li>CISC complex<ul>
<li>x86，一条指令一个复杂功能 </li>
<li>采用存储程序的设计思想，一个比较通用的电路配合存储部件完成指令</li>
</ul>
</li>
<li>RISC reduced<ul>
<li>arm，一条指令一个基本动作，复杂功能由基本功能组成 </li>
<li>功耗更低，一条指令一个电路，电路相对简单</li>
<li>并行、流水线简单</li>
<li>运算类数字一定来自于寄存器</li>
</ul>
</li>
</ul>
</li>
<li><p>对比表P195</p>
<ul>
<li>CISC复杂庞大</li>
<li>CISC字长不固定</li>
<li>CISC访存指令不限制 RISC只有Load&#x2F;Store</li>
<li>CISC不同指令的执行时间、使用频率差距大  </li>
<li>通用寄存器CISC少！！！</li>
<li>目标代码CISC很难优化</li>
<li>CISC微程序、RISC组合逻辑</li>
<li>CISC可以通过一定的方式实现指令流水线</li>
<li>RISC必须实现！！！！</li>
</ul>
</li>
</ul>
</li>
<li>间址结束 MAR存放操作数的地址</li>
</ul>
<h2 id="C5-中央处理器"><a href="#C5-中央处理器" class="headerlink" title="C5 中央处理器"></a>C5 中央处理器</h2><ul>
<li>本章节问题：CU如何控制的呢？</li>
</ul>
<h3 id="5-1-CPU功能与基本结构"><a href="#5-1-CPU功能与基本结构" class="headerlink" title="5.1 CPU功能与基本结构"></a>5.1 CPU功能与基本结构</h3><ul>
<li><p>CPU （5_1视频图很重要！！！！）⭐️⭐️⭐️⭐️⭐️⭐️⭐️⭐️</p>
<ul>
<li>（程序员是否可见；可见（不透明）不可见（透明））</li>
<li>运算器（数据加工）<ul>
<li>算术逻辑单元（ALU）</li>
<li>暂存寄存器</li>
<li>累加寄存器（ACC）<strong>可见</strong></li>
<li>通用寄存器组（堆栈指针等）<strong>可见</strong><ul>
<li>（与ALU有专用数据通路，可多路选择器控制）</li>
<li>或者三态门控制，避免一直向ALU传送数据</li>
<li>专用结构复杂，硬件量大</li>
<li>单总线的话也可以完成：结构简单容易时间，但冲突多<ul>
<li>R0+R1，一起送总线会冲突</li>
<li>暂存寄存器：暂存从主存读来的数据（放通用会破坏原有内容）</li>
</ul>
</li>
</ul>
</li>
<li>程序状态字寄存器（PSW） （也叫标志寄存器）<strong>可见</strong></li>
<li>乘商寄存器（MQ）</li>
<li>移位器</li>
</ul>
</li>
<li>控制器 （控制协调计算机部件执行程序的指令序列、取、分析、执行）<ul>
<li>注意区别CPU内部总线和外部数据总线</li>
<li>控制单元（CU）：控制单元，分析指令，给出控制信号<ul>
<li>指令译码器（ID）：对<strong>操作码</strong>字段译码，向控制器提供特定操作信号<ul>
<li>指令的操作码作为指令译码器的输入</li>
<li>对应输出端被选通，决定接下来是什么微操作</li>
</ul>
</li>
<li>时序系统：产生各种时序信号 </li>
<li>微操作信号发生器：根据IR和PSW以及时序信号来形成控制信号<ul>
<li>那些PCout PCin 就是他发出的</li>
</ul>
</li>
</ul>
</li>
<li>指令寄存器（IR）：当前执行的那条指令</li>
<li>程序计数器（PC）：下一条指令在主存中的存放地址	<strong>可见</strong></li>
<li>存储器地址寄存器（MAR）：存放要访问的主存单元的地址</li>
<li>存储器数据寄存器（MDR）：存放向主存写入 &#x2F; 从主存读出的信息<ul>
<li>MDRin MDRout（从CPU内部数据总线接受）</li>
<li>MDRinE MDRoutE（从CPU外部数据总线接受）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>	</p>
</li>
<li><p>重要过程 ⭐️这一行一行都是微操作啊！对应着inout的控制信号</p>
<ul>
<li>取指周期：把PC对应的地址从M中找出来放到IR（取指后PC自动+1） <ul>
<li>（PC）-&gt; MAR（本环节后CU会向控制总线发出读信号，传到MM）</li>
<li>M（MAR）-&gt; MDR</li>
<li>（MDR）-&gt; IR（此时MDR和IR是一样的，复制一份）</li>
</ul>
</li>
<li>分析指令：指令的操作码送到CU，CU分析指令<ul>
<li>OP（IR）-&gt; CU</li>
</ul>
</li>
<li>间址周期<ul>
<li>AD（IR） -&gt; MAR 或者AD（MDR）-&gt; MAR</li>
<li>（本环节后CU会向控制总线发出读信号，传到MM）</li>
<li>M（MAR）-&gt; MDR（得到了有效地址）</li>
</ul>
</li>
<li>执行周期<ul>
<li>分开讨论</li>
</ul>
</li>
<li>中断周期（MAR发送地址给内存）<ul>
<li>暂停当前任务取完成其他任务</li>
<li>为了恢复当前任务，需要保存断点（SP-1，然后放入）</li>
<li>也是倒过来的，从上往下放PC的值</li>
<li>本质上就是把断点保存在某个存储单元</li>
<li>保存断点，送中断向量，处理中断请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-指令周期的数据流"><a href="#5-2-指令周期的数据流" class="headerlink" title="5.2 指令周期的数据流"></a>5.2 指令周期的数据流</h3><ul>
<li>指令周期：CPU从主存中取出并执行一条指令所需要的全部时间⭐️<ul>
<li>一个指令周期包含多个CPU周期（机器周期）<ul>
<li>机器周期<ul>
<li>定长：一个机器周期内节拍数相同</li>
<li>不定长：不同</li>
</ul>
</li>
</ul>
</li>
<li>一个CPU周期包含很多时钟周期（节拍、T周期、CPU时钟周期）<ul>
<li>主频 3.0GHz 1s3.0G个节拍</li>
</ul>
</li>
<li>取指周期<ul>
<li>取指令</li>
<li>译码（超快）</li>
</ul>
</li>
<li>执行周期</li>
<li>举例子<ul>
<li>空指令：整个指令周期就是取址周期</li>
<li>加法指令：第一个周期取，第二个周期执行，可能长度不同</li>
<li>乘法指令：取+执行，执行肯定比加法长</li>
<li>间接寻址：取指周期+间址周期+执行周期</li>
<li><strong>带中断周期的指令</strong>：取周期+间周期+执行周期+中断周期<ul>
<li>四个触发器来确定处于什么周期</li>
<li>取 ER&#x3D;1，为了取</li>
<li>间 IND&#x3D;1，为了有效地址</li>
<li>执 EX&#x3D;1，为了取操作数</li>
<li>断 INT&#x3D;1，<strong>为了保存程序断点（伏笔）</strong></li>
<li>都有访存目的不同</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>指令执行方案<ul>
<li>单指令周期<ul>
<li>所有指令相同执行时间</li>
<li>指令之间串行</li>
<li>指令周期取决于最长的那条指令</li>
<li>导致本来短的也变长，效率变差</li>
</ul>
</li>
<li>多指令周期<ul>
<li>不同类型指令不同的步骤，指令之间串行</li>
<li>可以用不同的时钟周期来完成不同指令的执行过程</li>
<li>需要更复杂硬件设计</li>
</ul>
</li>
<li>流水线方案<ul>
<li>每一个时钟周期启动一条指令</li>
<li>多条指令同时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-数据通路的功能（ALU需要配合暂存器）终于整明白了！！！！"><a href="#5-3-数据通路的功能（ALU需要配合暂存器）终于整明白了！！！！" class="headerlink" title="5.3 数据通路的功能（ALU需要配合暂存器）终于整明白了！！！！"></a>5.3 数据通路的功能（ALU需要配合暂存器）终于整明白了！！！！</h3><ul>
<li><p>CPU内部单总线结构</p>
<ul>
<li>视频5_3_1 ⭐️</li>
<li>举例ADD （R0） R1</li>
<li>((R0))+(R1)-&gt;(R0)写回R0指向的存储单元</li>
<li>ADD 目的 源 放回R0</li>
<li>需要一次间接寻址</li>
</ul>
</li>
<li><p>CPU多总线结构</p>
</li>
<li><p>CPU专用数据通路</p>
<ul>
<li>从连接到CPU内部总线的xxin xxout</li>
<li>变成C0 C1 C2等等</li>
</ul>
</li>
<li><p>CPU的功能</p>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li><strong>中断处理</strong> （鼠标）</li>
</ul>
</li>
<li><p>指令周期问题</p>
<ul>
<li>指令周期：cpu从主存取出并执行一条指令的全部过程</li>
<li>指令周期由若干机器周期组成，机器周期又叫CPU周期</li>
<li>一个机器周期又包含很多时钟周期，节拍，CPU时钟周期</li>
<li>时钟周期是CPU操作的最基本单位</li>
</ul>
</li>
</ul>
<h3 id="5-4-控制器的功能和工作原理"><a href="#5-4-控制器的功能和工作原理" class="headerlink" title="5.4 控制器的功能和工作原理"></a>5.4 控制器的功能和工作原理</h3><ul>
<li><p>回顾</p>
<ul>
<li>一个节拍内可以并行完成多个相容微操作</li>
<li>同一个微操作可能在同指令的不同阶段使用</li>
<li>为了简化设计选择定长机器周期，以可能出现的最大节拍数为准（访存所需的为参考）</li>
</ul>
</li>
<li><p>如何确定当前节拍应该发出哪些微命令？</p>
<ul>
<li>指令操作码：译码器</li>
<li>目前机器周期：FE IND EX INT（集成在CU内）</li>
<li>节拍信号：节拍发生器确定当前第几个节拍 t1t2t3..循环</li>
<li>机器状态条件：PSW ACC I&#x2F;O 主存</li>
</ul>
</li>
<li><p>如何实现微命令对应的微操作？</p>
<ul>
<li>对应的控制信号接上对应的节拍发生器，机器周期，与门！！ </li>
<li>逻辑表达式决定了电路设计</li>
<li>最后的结果就是，某一条（如M（MAR）-&gt; MDR）需要的与门是如何建立的 <ul>
<li>在FE IND EX三个阶段的T1节拍 都要用，再配合机器状态条件</li>
</ul>
</li>
</ul>
</li>
<li><p>控制单元CU的实现 </p>
<ul>
<li>硬布线：RISC：指令很多，很复杂，扩充指令很难<ul>
<li>纯硬件实现</li>
<li>让微操作对应的控制信号有效、选通 ⭐️</li>
<li>设计步骤<ul>
<li>分析每个阶段微操作序列（确定哪些指令在什么阶段，在什么条件下会用）</li>
<li>选择CPU控制方式（定长？不定？） </li>
<li>安排微操作时序（如何用三个节拍完成全部微操作？）<ul>
<li>微操作顺序不能随意修改</li>
<li>对象不同尽量一个节拍</li>
<li>短的尽量一个节拍，允许先后</li>
</ul>
</li>
<li>电路设计</li>
</ul>
</li>
</ul>
</li>
<li>微程序：CISC（考频更高）<ul>
<li><p>软硬件相集合 </p>
</li>
<li><p>程序（简单来说，程序的一条条指令就是一个个微程序，微程序再对应自己微指令）</p>
<ul>
<li>指令是对程序步骤的描述，微程序是对指令执行的描述<br>  - 指令是对微指令功能的封装 </li>
<li>指令1：微程序1<ul>
<li>微指令11<ul>
<li>微命令111：完成微操作1xxx</li>
<li>微命令112：完成微操作2xxx</li>
</ul>
</li>
<li>微指令12</li>
</ul>
</li>
</ul>
</li>
<li><p>CU中包含（工作流程就看书P231）</p>
<ul>
<li>CM 控制存储器：存放指令对应的微程序，可用只读存储器ROM构成，非易失<ul>
<li>地址访问，指令1的微程序，指令2的微程序</li>
</ul>
</li>
<li>CMAR，别名uPC，微地址寄存器，接受微地址形成部件送来的微地址<ul>
<li>为在CM中读取微指令做准备</li>
<li>其实是PC和MAR的一个结合体</li>
</ul>
</li>
<li>地址译码（器）<ul>
<li>把地址码转化为存储单元的控制信号    </li>
<li>MAR中的地址需要通过地址译码器才能选中主存中的一个单元</li>
<li>对比：那么同样CMAR中的下地址想要选中CM中的单元也需要地址译码</li>
</ul>
</li>
<li>CMDR，别名uIR <ul>
<li>用于存放从CM中取出的<strong>微指令</strong>，与微指令字长相等</li>
<li>下地址再给顺序逻辑</li>
<li>操作控制部分直接传出CU给到CPU内部和系统总线的控制信号</li>
<li>微指令基本格式：<ul>
<li>操作控制 循序控制 两个字段 不同bit位<ul>
<li>操作控制 当前微指令完成哪些微操作</li>
<li>顺序控制 指明下一条微指令的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微地址形成部件<ul>
<li>产生初始微地址以保证微地址的连续执行（又原来程序指令的操作码给出）</li>
</ul>
</li>
<li>顺序逻辑<ul>
<li>标志、CLK</li>
</ul>
</li>
</ul>
</li>
<li><p>所有指令的取址周期、间址周期、中断周期对应的微指令序列一样，可共享</p>
<ul>
<li>CM中取址周期、间址周期、中断周期就一份</li>
<li>对应不同的执行周期的微程序不一样</li>
</ul>
</li>
<li><p>补充：指令的地址码部分有一部分会用来解释寻址方法</p>
<ul>
<li>寻址特征也会送给顺序逻辑 判断是否需要跳过</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>微指令的设计</p>
<ul>
<li>微命令微操作一一对应，一个微命令对应着一个输出线</li>
<li>微命令可以并行，因此一条微指令可以包含多个微命令</li>
<li>格式（首先要知道微命令是否相容互斥）<ul>
<li>水平型微指令（一条微指令可以定义多个可以并行的微命令）<ul>
<li>格式：操作控制、顺序控制</li>
<li>微程序短，执行速度快</li>
<li>微指令长，编写烦</li>
</ul>
</li>
<li>垂直型微指令（一条微指令1定义一个微命令，由微操作码规定具体功能）<ul>
<li>微操作码、目的地址、源地址</li>
<li>微程序长，执行慢</li>
<li>微指令短，简单编写</li>
</ul>
</li>
<li>混合型 微指令<ul>
<li>都不长，很综合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>微指令编码（控制）方式：如何对控制字段进行编码 </p>
<ul>
<li>目标：保证速度的情况下尽量缩短微指令字长</li>
<li>水平型微指令<ul>
<li>直接编码方式：每一<strong>位</strong>代表一个微操作命令 <ul>
<li>控存容量变大</li>
</ul>
</li>
<li>字段直接编码方式：（每一个编码就是（PC）-&gt; MAR 这种了 这就是微操作）⭐️<ul>
<li>微指令控制字段分段</li>
<li>一个段内互斥</li>
<li>不同段相容 </li>
<li>信息位不能太多，否则译码线路复杂，时间增加</li>
<li>留状态000 表示不操作</li>
<li>稍微比直接编码慢一点</li>
</ul>
</li>
<li>字段间接编码方式<ul>
<li>一个字段的微命令可能需要另一个字段的微命令来解释</li>
<li>也叫隐式编码</li>
<li>缩短字长，但并行控制降低</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>微指令地址的行程方式：地址字段编码问题 ⭐️</p>
<ul>
<li><strong>下地址字段直接指出，断定方式</strong> 需要几位的问题 32x4+2</li>
<li>根据机器指令的操作码形成，机器指令的操作码部分经过微地址形成部件形成</li>
<li><strong>增量计数器法：（CMAR）+1 -&gt; CMDR</strong></li>
<li>分支转移需要指明转移方式和转移地址</li>
<li>通过测试网络：顺序逻辑来</li>
<li>由硬件直接产生微程序入口地址<ul>
<li>第一条微指令地址，专门硬件产生</li>
<li>中断周期微程序首地址</li>
</ul>
</li>
</ul>
</li>
<li><p>微程序控制单元的设计</p>
<ul>
<li>对比<ul>
<li>硬布线是选通线的问题</li>
<li>微程序需要把指令操作码送给微地址形成部件</li>
<li>然后微地址形成部件指明这条<strong>指令</strong>的执行周期在微程序的起始地址</li>
</ul>
</li>
<li>写出微操作序列</li>
<li>写出指令的微操作命令和节拍安排</li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ul>
</li>
<li><p>微程序设计分类</p>
<ul>
<li>动态微程序设计<ul>
<li>通过改变微指令和微程序来改变机器指令，采用EPROM</li>
</ul>
</li>
<li>静态微程序设计<ul>
<li>微程序无需改变 使用ROM （CM）</li>
</ul>
</li>
</ul>
</li>
<li><p>毫微程序设计</p>
<ul>
<li>深层套娃</li>
</ul>
</li>
</ul>
<h3 id="5-5-异常和中断机制"><a href="#5-5-异常和中断机制" class="headerlink" title="5.5 异常和中断机制"></a>5.5 异常和中断机制</h3><h3 id="5-6-指令流水线"><a href="#5-6-指令流水线" class="headerlink" title="5.6 指令流水线"></a>5.6 指令流水线</h3><ul>
<li><p>指令执行过程：</p>
<ul>
<li>取指：根据PC访问主存，取出一条送到IR</li>
<li>分析：对指令操作码译码，根据地址字段找到EA，取出操作数</li>
<li>执行：根据操作码，完成功能，写结果到指定位置</li>
</ul>
</li>
<li><p>执行方式</p>
<ul>
<li>顺序执行方式：控制简单，硬件代价小<ul>
<li>速度较慢，处理机只有一条在执行，利用率低</li>
</ul>
</li>
<li>引入流水线<ul>
<li>一次重叠方式：需要硬件较大开销，控制过程更复杂，各部件利用率高 <ul>
<li>二次重叠方式：<ul>
<li>更多阶段，不同阶段硬件独立，增加并发度</li>
<li>五个阶段比较常见捏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图 （P248）</p>
<ul>
<li>指令执行过程图<ul>
<li>列是指令序列，行是时间</li>
</ul>
</li>
<li>时空图<ul>
<li>列不同的阶段，行是时间</li>
</ul>
</li>
</ul>
</li>
<li><p>流水线的性能指标	</p>
<ul>
<li>吞吐率：任务数n，处理完成n个任务的时间为Tk<ul>
<li>吞吐率&#x3D;n&#x2F;Tk（单位时间完成任务数量）</li>
<li>Tk&#x3D;（k+n-1）t</li>
</ul>
</li>
<li>装入时间：第一条指令从开始到结束</li>
<li>排空时间：最后一条指令从开始到结束</li>
<li>一般取t为一个时钟周期</li>
<li>加速比：<ul>
<li>完成同样一批任务不是用流水线所用时间和使用所用时间只比</li>
<li>最大加速比就是k（一个指令被分的阶段数）</li>
</ul>
</li>
<li>效率：流水线设备利用率<ul>
<li>忙碌时间&#x2F;全部时间（面积）  </li>
<li>最高效率1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-7-多处理机的基本概念"><a href="#5-7-多处理机的基本概念" class="headerlink" title="5.7 多处理机的基本概念"></a>5.7 多处理机的基本概念</h3><ul>
<li><p>间址结束 MAR存放操作数的地址</p>
</li>
<li><p>空指令NOP：1个机器周期，只需要取指令然后分析指令</p>
</li>
<li><p>加法指令ADD：2个机器周期，有可能不等</p>
</li>
<li><p>乘法指令MLT：2个，但是不同指令执行周期可能不等</p>
</li>
<li><p>具有间址寻址的指令：3个、取地址周期、间址周期、执行周期</p>
</li>
<li><p>指令与微指令，程序与微程序</p>
<ul>
<li><strong>指令</strong>是对程序执行步骤的描述</li>
<li>微指令是对<strong>指令</strong>执行步骤的描述</li>
<li>程序是由指令序列构成</li>
<li>微程序下：每一种指令对应一个微程序一个微程序要执行很多微指令，微指令是由很多微操作构成的</li>
</ul>
</li>
<li><p>经典五段式指令流水线 5_6_2（MIPS架构 是第一个RISC ARM是其延伸）⭐️</p>
<ul>
<li>有些指令可能会跳过某些阶段，虽然不需要，但也逃不掉捏</li>
<li>每个阶段耗时一样，最长考齐，100ns，为了等待，需要一个缓冲寄存器（锁存器）</li>
<li>（1）IF（控制器内部触发器）Instruction （指令） Fetch<ul>
<li>根据PC 从指令cache中找到指令放到<strong>IF阶段的锁存器</strong></li>
</ul>
</li>
<li>（2）ID Decode<ul>
<li>译码+取数（从通用寄存器中） 放到<strong>锁存器（Imm放立即数）</strong></li>
</ul>
</li>
<li>（3）EX execute<ul>
<li>取出操作数，执行，找到EA</li>
</ul>
</li>
<li>（4）M memory（访存）<ul>
<li>根据地址从数据cache中找到到数据</li>
</ul>
</li>
<li>（5）Writeback（写回）<ul>
<li>写回主存or锁存器or某个通用寄存器</li>
</ul>
</li>
<li>分析：<ul>
<li>指令数据两个cache模块，14阶段并行</li>
</ul>
</li>
</ul>
</li>
<li><p>经典的五类指令（Rs Rd）</p>
<ul>
<li>运算类指令<ul>
<li>ADD Rs Rd ：（Rs）+（Rd）-&gt; Rd</li>
<li>ADD #996，Rd ：#996+（Rd）-&gt; Rd</li>
<li>SHL Rd：（Rd）&lt;&lt;&lt;2 -&gt; Rd（左移）</li>
<li>无访存，但得等，M为空段</li>
</ul>
</li>
<li>LOAD指令<ul>
<li>LOAD Rd，996（Rs）：（996+（Rs））-&gt; Rd</li>
<li>LOAD Rd，mem：（mem）-&gt; Rd</li>
</ul>
</li>
<li>STORE指令<ul>
<li>STORE Rs，996（Rd）：Rs -&gt;（996+（Rd））</li>
<li>STORE Rs，mem：Rs -&gt;（mem）</li>
</ul>
</li>
<li>条件转移指令<ul>
<li>beq Rs，Rt，#偏移量 比较Rs和Rt内数字 一样就转移</li>
<li>bne Rs，Rt，#偏移量 不一样就转移</li>
<li>（Rs）（Rt）</li>
<li>判断成功（PC）+指令字长+（偏移量x指令字长）-&gt; PC</li>
<li>否则（PC）+指令字长-&gt; PC</li>
</ul>
</li>
<li>无条件转移指令<ul>
<li>jmp #偏移量：（PC）+指令字长+（偏移量x指令字长）-&gt; PC</li>
<li>WrPC耗时比EX短（今早的发现PC的值，越早避免控制冲突），EX阶段直接改</li>
</ul>
</li>
<li>问问题要回答相关（数据相关or顺序问题）：<ul>
<li>下一个的IF段必须在前一个的ID段后才能开始，否则覆盖IF段锁存器的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>影响指令流水线的因素 ⭐️</p>
<ul>
<li>结构相关（资源冲突）<ul>
<li>可以让后面的暂停</li>
<li>可以资源重复配置（data 指令cache）</li>
</ul>
<p>	</p>
</li>
<li>数据相关（数据冲突）<ul>
<li>同步问题</li>
<li>硬件阻塞or软件插入“NOP”空指令</li>
<li>数据旁路技术</li>
<li>编译优化，编译器自动调整指令顺序来解决数据相关</li>
</ul>
</li>
<li>控制相关（控制冲突）<ul>
<li>转移指令或者其他改变PC的值，跳转导致断流，会控制冲突（中断也会）</li>
<li>解决方法：<ul>
<li>转移指令分支预测：简单预测、动态预测</li>
<li>欲取转移成功和不成功的两个控制流方向上的目标指令</li>
<li>加快和提前形成条件码（提前形成进位类似）</li>
<li>提高转移方向猜准率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流水线的分类</p>
<ul>
<li>部件功能、处理机级、处理机间 <ul>
<li>部件功能级流水线<ul>
<li>某个节点比如EX再分段</li>
<li>分段后并行</li>
<li>浮点数加法：求阶差、对阶、尾数想家、规格化</li>
</ul>
</li>
<li>处理机级流水线<ul>
<li>指令流水线：指令分成多个子过程</li>
</ul>
</li>
<li>处理机间流水线 <ul>
<li>宏流水，一个处理机完成某一个任务，不同的CPU不同的工作</li>
<li>每个处理机完成一个任务后把结果存放在下一个处理器所共享的存储器</li>
</ul>
</li>
</ul>
</li>
<li>单功能流水线和多功能流水线<ul>
<li>单功能流水线：专门功能、浮点数加法</li>
<li>多功能流水线：不同的功能，指令流水线就是</li>
</ul>
</li>
<li>静态流水线和动态流水线（各段之间的连接方式）<ul>
<li>静态：各段只能按同一种功能的连接方式工作</li>
<li>动态：某些段某种运算，另些段另一种运算</li>
</ul>
</li>
<li>线性流水线和非线性流水线<ul>
<li>线性，输入输出只能一次，无反馈电路</li>
<li>非线形流水线，需要反馈电路来某些功能数次执行，递归运算</li>
</ul>
</li>
</ul>
</li>
<li><p>流水线的多发技术</p>
<ul>
<li>超标量技术<ul>
<li>每个时钟周期可以并发执行多条独立指令</li>
<li>要配置多个功能部件</li>
<li>不能调整指令的执行顺序</li>
</ul>
</li>
<li>超流水线技术<ul>
<li>一个时钟周期内再分段</li>
<li>一个时钟周期内一个功能部件使用多次</li>
</ul>
</li>
<li>超长指令字<ul>
<li>由编译程序挖掘出指令间的潜在并行性</li>
<li>多条可并行的指令组合成一条</li>
<li>具有多个操作码字段的超长指令字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-7-多处理机的基本概念（选择）"><a href="#5-7-多处理机的基本概念（选择）" class="headerlink" title="5.7 多处理机的基本概念（选择）"></a>5.7 多处理机的基本概念（选择）</h3><ul>
<li><p>SISD、SIMD、MIMD、向量处理机 ⭐️</p>
<ul>
<li>SISD（单指令单数据流）<ul>
<li>一段时间内仅执行一条指令</li>
<li>指令序列只能并发，不能并行，每条指令只能处理一两个数据</li>
<li>一个处理器一个主存</li>
<li>采用指令流水线需要多个功能部件，用模块交叉存储</li>
<li>不是数据级并行</li>
</ul>
</li>
<li>SIMD<ul>
<li>一个指令流同时对多个数据流进行处理</li>
<li>指令序列只能并发，不能并行，每条指令只能处理多个具有相同特征的数字</li>
<li>是数据级并行</li>
<li>一个处理器内有很多局部的存储器和多个ALU（执行单元）<ul>
<li>一个CU， 一个主存</li>
</ul>
</li>
<li>早起某些显卡（红色滤镜）</li>
<li>数组元素的重复处理</li>
<li>不同执行单元执行同一条指令，处理不同的数据</li>
</ul>
</li>
<li>MISD<ul>
<li>同时执行多条指令，处理同一个数据的脑瘫不存在</li>
</ul>
</li>
<li>MIMD<ul>
<li>多条指令分别处理多个不同的数据</li>
<li>各指令序列并行执行，分别处理多个不同的数据</li>
<li>线程级并行</li>
<li>可以分多处理机系统和多计算机系统<ul>
<li>多处理机系统（共享存储的多处理机系统）<ul>
<li>一个计算机，处理器之前可以访问同一个主存，物理地址共享</li>
<li>主存传递一台计算机多个处理器共享内存</li>
</ul>
</li>
<li>多计算机系统<ul>
<li>计算机之间只能通过消息传递来传递数据 </li>
<li>多个计算机多个处理机多个存储器，物理地址独立</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>向量处理器<ul>
<li>指令的操作对象是向量</li>
<li>多个处理单元，多组向量寄存器</li>
<li>主存应该采用多个端口同时读取的交叉多模块存储器</li>
<li>主存大小限制了阶梯规模</li>
</ul>
</li>
</ul>
</li>
<li><p>共享内存多处理器&#x3D;多核心处理器</p>
<ul>
<li>1、共享同一个主存，地址共享，LOAD STORE</li>
<li>2、一个处理器包含多个核、共享主存也共享最低级的Cache</li>
</ul>
</li>
<li><p>支持硬件多线程（不支持就要不断切换寄存器和主存的值）⭐️</p>
<ul>
<li>细粒度多线程<ul>
<li>各个时钟周期轮流发射多个线程的指令</li>
<li>一个时钟周期切换一次进程</li>
<li>代价低</li>
<li>指令级并行</li>
</ul>
</li>
<li>粗粒度多线程<ul>
<li>连续几个时钟周期都发射统一线程的指令序列，流水线阻塞切换线程</li>
<li>阻塞切换进程</li>
<li><strong>需要重载流水线代价高</strong>因为重载所以代价高</li>
<li>指令级并行</li>
</ul>
</li>
<li>同时多线程（SMT）<ul>
<li>一个时钟周期内同时发射多个线程的指令</li>
<li>不切换</li>
<li>无代价</li>
<li>指令级并行，线程级并行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C6-总线"><a href="#C6-总线" class="headerlink" title="C6 总线"></a>C6 总线</h2><h3 id="6-1-总线概述"><a href="#6-1-总线概述" class="headerlink" title="6.1 总线概述"></a>6.1 总线概述</h3><ul>
<li><p>概述</p>
<ul>
<li>早期为何要用：原本大多数采用分散链接方式，不容易随时增减外部设备<ul>
<li>用了总线就可以方便链接</li>
</ul>
</li>
<li>共享与分时<ul>
<li>总线可以挂多个部件，每个部件之间较灰暗信息可以通过这组线路<strong>分时共享</strong></li>
<li>分时就是同时只能有一个发送信息</li>
</ul>
</li>
<li>总线的特性<ul>
<li>机械特性：尺寸形状引脚</li>
<li>电气特性：传输方向和有效范围</li>
<li>功能特性：每根弦的弓嫩难过</li>
<li>时间特性：信号和时序关系</li>
</ul>
</li>
<li>串并总线 <ul>
<li>串行总线（USB），一次一个bit数据，成本低，远距离可以，不易跳变</li>
<li>并行总线，总线的逻辑时序比较简单，电路容易，信号线多，远距成本高</li>
</ul>
</li>
<li>总线功能分类<ul>
<li>片内总线：是芯片内部的总线，是CPU内部寄存器之间，寄存器与ALU之间的连接线</li>
<li>系统总线：是计算机系统内功能部件相互连接的总线<ul>
<li>数据总线（DB）：传输数据信息，包括指令和操作数，机器字长，存储字长相关，<strong>双向</strong>，可以选一个保持一致</li>
<li>地址总线（AB）：传输地址信息，与设备数量，位数与主存地址空间相关、设备数量相关，<strong>单向</strong></li>
<li>控制总线（CB）：传输控制信息，单根单向，总的双向</li>
</ul>
</li>
<li>通信总线：用于计算机系统之间活着计算机系统与其他系统之间信息传输的总线<ul>
<li>外部总线</li>
</ul>
</li>
</ul>
</li>
<li>数据通路表示表示数据流经的路径<ul>
<li>总线是承载媒介，地址总线也可以是媒介</li>
</ul>
</li>
</ul>
</li>
<li><p>系统总线的结构</p>
<ul>
<li>单总线结构：一组系统总线，允许直接交换信息。（系统三根）<ul>
<li>容易介入新设备，带宽低，争用，不支持并发（实则并行）</li>
<li>快速总线，慢速I&#x2F;O，浪费性能</li>
</ul>
</li>
<li>双总线结构：系统三根+I&#x2F;O<ul>
<li>用通道代替I&#x2F;O与总线的直接相连，增加I&#x2F;O总线</li>
<li><strong>支持突发传送，传出一个地址，收到多个地址连续的数据</strong></li>
</ul>
</li>
<li>三总线结构 ：系统三根+I&#x2F;O+DMA总线<ul>
<li>DMA也是缓和速度矛盾（Direct Memory Access）直接内存访问 </li>
<li>主存一整块传送给CPU</li>
<li>提高I&#x2F;O设备性能</li>
<li>系统工作效率较低（三个总线只能一个工作</li>
</ul>
</li>
<li>四总线结构：CPU</li>
</ul>
</li>
<li><p>字长⭐️</p>
<ul>
<li>程序计数器（PC）取决于指令的地址，定位指令，4GB，字长32位&#x3D;4B，PC：30位</li>
<li>通用寄存器（用于存放数据或者地址）位数和机器字长相等</li>
<li>指令寄存器（IR）的位数取决于指令字长</li>
<li><strong>指令字长一般取字节 &#x2F; 存储字长的整数倍，与机器字长无关</strong><ul>
<li>指令字长等于存储字长的情况下，取指周期等于机器周期</li>
</ul>
</li>
</ul>
</li>
<li><p>总线性能指标</p>
<ul>
<li>总线的传输周期（总线周期）<ul>
<li><strong>一次总线操作</strong>所需的时间（申请、寻址、传输、结束，四个阶段） </li>
<li>由若干个总线时钟周期构成</li>
<li>传一次数据要多久</li>
</ul>
</li>
<li>时钟周期<ul>
<li>机器的时钟周期 </li>
<li>关系魔幻：<ul>
<li>大多数情况下，一个总线周期包含多个总线时钟周期</li>
<li>有的时候一个总线周期就是一个总线时钟周期</li>
<li>有时候一个总线时钟周期包含多个总线周期<ul>
<li>有的总线，上升沿和下降沿都进行数据传输，一个周期，两次传送</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>	 	  </p>
</li>
<li>工作频率<ul>
<li>总线周期的倒数</li>
<li>一秒传送几次数据</li>
</ul>
</li>
<li>总线时钟频率<ul>
<li>时钟周期的倒数</li>
<li>3.0GHz</li>
</ul>
</li>
<li>宽度（位宽）<ul>
<li>数据总线的根数，并行传输数据位数</li>
</ul>
</li>
<li>带宽（最高数据传输速率和有效数据传输速率不一样）<ul>
<li>每秒可以传输多少信息</li>
<li>工作频率x总线宽度</li>
</ul>
</li>
<li>复用<ul>
<li>一种信号线不同时间传送不同的信息，较少的线，更多信息</li>
<li>节省空间成本</li>
</ul>
</li>
<li>信号线数<ul>
<li>地址总线，数据总线，控制总线根数总和</li>
</ul>
</li>
</ul>
</li>
<li><p>并不一定并行就比串快，因为带宽由频率和总线宽度同时决定</p>
</li>
</ul>
<h3 id="6-2-总线事务和定时"><a href="#6-2-总线事务和定时" class="headerlink" title="6.2 总线事务和定时"></a>6.2 总线事务和定时</h3><ul>
<li><p>仲裁（争用问题）</p>
<ul>
<li>总线是互斥共享的资源</li>
<li>获得总线控制权的设备</li>
<li>主设备：获得总线控制权的设备</li>
<li>从设备：被主设备访问的设备，只能响应从主设备发来的各种总线命令</li>
<li>竞争主线控制权，选择一个方式获得控制权就叫总线仲裁</li>
<li>总线控制器的判优，仲裁逻辑按照一定的优先登记顺序确定</li>
<li>集中仲裁方式<ul>
<li>链式查询方式：（越近优先级越高，优先级固定）<ul>
<li>BS：总线允许 </li>
<li>BR：总线请求</li>
<li>BS：总线忙（建立者位获得控制权的）</li>
<li>三根都属于控制总线，三根信号线</li>
<li>BR提出，控制器通过BG发送高电平</li>
<li>找到想要的给控制权，然后发送总线忙表示已经占用了，撤销BG</li>
<li>使用完就撤销总线忙</li>
<li>坏一个就G</li>
</ul>
</li>
<li>计数器定时查询方式：（需要计时器）<ul>
<li>计数值通过设备地址线发向各个部件</li>
<li>空闲就不断通过计数器来赋予资格</li>
<li>计数器初值可以改变优先次序</li>
<li>循环技术很公平</li>
<li>需要更多的控制线，控制相对链式复杂一些</li>
</ul>
</li>
<li>独立请求方式：（排队器）<ul>
<li>每个设备和控制器都有一个BR和BG</li>
<li>用完撤销BS，释放BG，分配给下一个</li>
<li>响应快，灵活，控制线多</li>
</ul>
</li>
</ul>
</li>
<li>分布仲裁方式（仲裁总线）<ul>
<li>不要中央仲裁器，每个主模块都有自己的仲裁器和仲裁号，多个仲裁器争用总线</li>
<li>把自己的总裁号发到共享仲裁总线，每个仲裁器将得到的仲裁号与自己的进行比较</li>
<li>如果总裁总线上的优先级高，则总线请求不予响应，并撤销仲裁号</li>
<li>最后获胜的留着</li>
</ul>
</li>
</ul>
</li>
<li><p>操作和定时（占用总线的一对设备如何进行数据传输）</p>
<ul>
<li>总线周期的四个阶段<ul>
<li>申请分配阶段<ul>
<li>传输请求 总线仲裁</li>
</ul>
</li>
<li>寻址阶段：通过总线发出需要访问模块的地址以及命令</li>
<li>传输阶段：数据交换，单向双向</li>
<li>结束阶段：有关信息撤出总线</li>
</ul>
</li>
<li>总线定时，控制四个阶段时间配合，是一个协议or规则<ul>
<li>同步通信（同步定时）：统一时钟<ul>
<li>用于总线长度较短，所接部件的存取时间比较接近的</li>
<li>传送快，逻辑简单</li>
<li>强制性同步，不能及时进行有效性检验，可靠性差</li>
</ul>
</li>
<li>异步通信（异步定时）：	  <ul>
<li>没有统一时钟，没有固定时间间隔，依靠互相制约的“握手”信号来实现定时控制</li>
<li>主设备提出交换请求，从设备回答</li>
<li>请求和回答信号的撤销是否互锁<ul>
<li>不互锁方式<ul>
<li>发送请求，不等回答，过段时间，自动撤销请求</li>
<li>收到请求，发出回答，过段时间，自动撤销回答</li>
</ul>
</li>
<li>半互锁方式<ul>
<li>等从回答才会撤销请求</li>
<li>回答的撤销就是自动啦</li>
</ul>
</li>
<li>全互锁方式 <ul>
<li>主发出必须等回答才撤销</li>
<li>必须等主已经撤销才撤销回答</li>
</ul>
</li>
</ul>
</li>
<li>总线周期长度可变，可以保证速度相差很大的部件</li>
<li>自动适应时间的配合 </li>
<li>比同步复杂，速度比同步慢，因为需要等应答</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>标准</p>
</li>
</ul>
<h2 id="C7-输入输出系统"><a href="#C7-输入输出系统" class="headerlink" title="C7 输入输出系统"></a>C7 输入输出系统</h2><h3 id="7-1-I-x2F-O系统基本概述"><a href="#7-1-I-x2F-O系统基本概述" class="headerlink" title="7.1 I&#x2F;O系统基本概述"></a>7.1 I&#x2F;O系统基本概述</h3><h3 id="7-2-I-x2F-O接口"><a href="#7-2-I-x2F-O接口" class="headerlink" title="7.2 I&#x2F;O接口"></a>7.2 I&#x2F;O接口</h3><h3 id="7-3-I-x2F-O方式"><a href="#7-3-I-x2F-O方式" class="headerlink" title="7.3 I&#x2F;O方式"></a>7.3 I&#x2F;O方式</h3>
            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：408-cop</li>
        <li>Post author：Picasun</li>
        <li>Create time：2023-02-15 16:05:26</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/02/15/408-cop/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/02/15/408-ds/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">408-ds</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/02/15/hello-world/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Hello World</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">Advertising space for rent ：)</div>
        <div class="page-title">408-cop</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#45%E2%80%99"><span class="nav-text">45’</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-text">C1 计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B-%E4%B8%8D%E8%80%83%E6%8D%8F"><span class="nav-text">计算机的发展历程 不考捏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">计算机系统的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">计算机的性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C2-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="nav-text">C2 数据的表示和运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">C3 存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">3.1 存储器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">3.2 主存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text">3.3 主存储器与CPU的连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">3.4 外部存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8Cache%E2%AD%90%EF%B8%8F"><span class="nav-text">3.5 高速缓冲存储器Cache	⭐️</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">3.6 虚拟存储器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-text">C4 指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-text">4.1 指令格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E2%AD%90%EF%B8%8F%EF%BC%88%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%8B%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AD%98%E6%94%BE%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="nav-text">4.2 指令的寻址方式⭐️（如何确定下一条指令的存放地址）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="nav-text">4.3 程序的机器级代码表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-CISC%E5%92%8CRISC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4.4 CISC和RISC的基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">C5 中央处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-CPU%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">5.1 CPU功能与基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-text">5.2 指令周期的数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%88ALU%E9%9C%80%E8%A6%81%E9%85%8D%E5%90%88%E6%9A%82%E5%AD%98%E5%99%A8%EF%BC%89%E7%BB%88%E4%BA%8E%E6%95%B4%E6%98%8E%E7%99%BD%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81"><span class="nav-text">5.3 数据通路的功能（ALU需要配合暂存器）终于整明白了！！！！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">5.4 控制器的功能和工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-text">5.5 异常和中断机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">5.6 指令流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">5.7 多处理机的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E9%80%89%E6%8B%A9%EF%BC%89"><span class="nav-text">5.7 多处理机的基本概念（选择）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C6-%E6%80%BB%E7%BA%BF"><span class="nav-text">C6 总线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0"><span class="nav-text">6.1 总线概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6"><span class="nav-text">6.2 总线事务和定时</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">C7 输入输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-I-x2F-O%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-text">7.1 I&#x2F;O系统基本概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-I-x2F-O%E6%8E%A5%E5%8F%A3"><span class="nav-text">7.2 I&#x2F;O接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-I-x2F-O%E6%96%B9%E5%BC%8F"><span class="nav-text">7.3 I&#x2F;O方式</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Picasun</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.1</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2022/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax defer>
                function odometer_init(){
                        let el = document.getElementsByClassName('odometer');
                        for (i = 0; i < el.length; i++) {
                            od = new Odometer({
                                el: el[i],
                                format: '( ddd).dd',
                                duration: 200
                            });
                        }
                }
                odometer_init();
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>





    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
